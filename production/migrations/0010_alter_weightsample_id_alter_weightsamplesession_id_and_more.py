# Generated by Django 5.0.14 on 2025-11-03 23:50

import logging
from decimal import Decimal, ROUND_HALF_UP

import django.db.models.deletion
from django.db import migrations, models


LOGGER = logging.getLogger('applacolina.migrations.production_room_records')
QUANTIZE_STEP = Decimal('0.01')


def _distribute_decimal(total: Decimal, weights: list[int]) -> list[Decimal]:
    if total in (None, ''):
        total = Decimal('0')
    if not isinstance(total, Decimal):
        total = Decimal(str(total))

    if total == 0 or not weights:
        return [Decimal('0')] * len(weights)

    weight_sum = sum(weights)
    if weight_sum <= 0:
        equal_share = (total / Decimal(len(weights))).quantize(QUANTIZE_STEP, rounding=ROUND_HALF_UP)
        result = [equal_share for _ in weights]
        if result:
            correction = total - sum(result)
            result[-1] = (result[-1] + correction).quantize(QUANTIZE_STEP, rounding=ROUND_HALF_UP)
        return result

    allocations: list[Decimal] = []
    remainder = total
    for index, weight in enumerate(weights):
        if index == len(weights) - 1:
            share = remainder
        else:
            ratio = Decimal(weight) / Decimal(weight_sum)
            share = (total * ratio).quantize(QUANTIZE_STEP, rounding=ROUND_HALF_UP)
            remainder -= share
        allocations.append(share.quantize(QUANTIZE_STEP, rounding=ROUND_HALF_UP))

    correction = total - sum(allocations)
    if allocations and correction != 0:
        allocations[-1] = (allocations[-1] + correction).quantize(QUANTIZE_STEP, rounding=ROUND_HALF_UP)
    return allocations


def _distribute_int(total: int, weights: list[int]) -> list[int]:
    if total in (None, ''):
        total = 0
    total = int(total)
    if total == 0 or not weights:
        return [0] * len(weights)

    weight_sum = sum(weights)
    if weight_sum <= 0:
        base = total // len(weights)
        remainder = total - base * len(weights)
        allocations = [base for _ in weights]
        if allocations:
            allocations[-1] += remainder
        return allocations

    allocations: list[int] = []
    assigned = 0
    for index, weight in enumerate(weights):
        if index == len(weights) - 1:
            share = total - assigned
        else:
            share = (total * weight) // weight_sum
            assigned += share
        allocations.append(int(share))
    return allocations


def migrate_room_records_forward(apps, schema_editor):
    ProductionRecord = apps.get_model('production', 'ProductionRecord')
    ProductionRoomRecord = apps.get_model('production', 'ProductionRoomRecord')
    BirdBatchRoomAllocation = apps.get_model('production', 'BirdBatchRoomAllocation')

    allocation_qs = (
        BirdBatchRoomAllocation.objects.select_related('room', 'room__chicken_house')
        .order_by('bird_batch_id', 'room__name')
    )
    allocations_by_batch: dict[int, list] = {}
    for allocation in allocation_qs.iterator():
        allocations_by_batch.setdefault(allocation.bird_batch_id, []).append(allocation)

    room_records_to_create = []
    processed = 0
    for record in ProductionRecord.objects.all().iterator():
        if ProductionRoomRecord.objects.filter(production_record_id=record.pk).exists():
            continue

        allocations = allocations_by_batch.get(record.bird_batch_id, [])
        if not allocations:
            LOGGER.info(
                "Skipping production record pk=%s date=%s: no room allocations found",
                record.pk,
                record.date,
            )
            continue

        weights = [allocation.quantity or 0 for allocation in allocations]
        production_split = _distribute_decimal(record.production, weights)
        consumption_split = _distribute_decimal(record.consumption, weights)
        mortality_split = _distribute_int(record.mortality, weights)
        discard_split = _distribute_int(record.discard, weights)

        for index, allocation in enumerate(allocations):
            room_records_to_create.append(
                ProductionRoomRecord(
                    production_record_id=record.pk,
                    room_id=allocation.room_id,
                    production=production_split[index],
                    consumption=consumption_split[index],
                    mortality=mortality_split[index],
                    discard=discard_split[index],
                )
            )

        processed += 1
        if processed % 100 == 0:
            ProductionRoomRecord.objects.bulk_create(room_records_to_create)
            LOGGER.info("Migrated %s production records into room records", processed)
            room_records_to_create = []

    if room_records_to_create:
        ProductionRoomRecord.objects.bulk_create(room_records_to_create)
        LOGGER.info("Migrated %s total production records into room records", processed)


def migrate_room_records_backward(apps, schema_editor):
    ProductionRoomRecord = apps.get_model('production', 'ProductionRoomRecord')
    ProductionRoomRecord.objects.all().delete()

class Migration(migrations.Migration):

    dependencies = [
        ('production', '0009_remove_chickenhouse_area_m2'),
    ]

    operations = [
        migrations.AlterField(
            model_name='weightsample',
            name='id',
            field=models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID'),
        ),
        migrations.AlterField(
            model_name='weightsamplesession',
            name='id',
            field=models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID'),
        ),
        migrations.CreateModel(
            name='ProductionRoomRecord',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('production', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Producción')),
                ('consumption', models.DecimalField(decimal_places=2, max_digits=10, verbose_name='Consumo')),
                ('mortality', models.PositiveIntegerField(verbose_name='Mortalidad')),
                ('discard', models.PositiveIntegerField(verbose_name='Descarte')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('production_record', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='room_records', to='production.productionrecord', verbose_name='Registro de producción')),
                ('room', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='production_records', to='production.room', verbose_name='Salón')),
            ],
            options={
                'verbose_name': 'Registro de producción por salón',
                'verbose_name_plural': 'Registros de producción por salón',
                'ordering': ('room__chicken_house__name', 'room__name'),
            },
        ),
        migrations.AddConstraint(
            model_name='productionroomrecord',
            constraint=models.UniqueConstraint(fields=('production_record', 'room'), name='uniq_room_production_record'),
        ),
        migrations.RunPython(migrate_room_records_forward, migrate_room_records_backward),
    ]
