<script>
    (() => {
      const app = document.getElementById('configurator-app');
      if (!app) {
        return;
      }
      const view = app.dataset.view || 'configurator';

      const API = {
        metadata: app.dataset.metadataUrl,
        generate: app.dataset.generateUrl,
        summaryTemplate: app.dataset.summaryUrlTemplate,
        assignmentsTemplate: app.dataset.assignmentsUrlTemplate,
        eligibleTemplate: app.dataset.eligibleUrlTemplate,
        calendarDetailTemplate: app.dataset.calendarDetailUrlTemplate,
        dashboard: app.dataset.dashboardUrl,
        positions: app.dataset.positionsUrl,
        positionDetailTemplate: app.dataset.positionDetailUrlTemplate,
        positionReorder: app.dataset.positionReorderUrl,
        operators: app.dataset.operatorsUrl,
        operatorDetailTemplate: app.dataset.operatorDetailUrlTemplate,
        restPeriods: app.dataset.restPeriodsUrl,
        restPeriodDetailTemplate: app.dataset.restPeriodDetailUrlTemplate,
      };

      const DEFAULT_SALARY_PAYMENT_TYPES = [
        { value: 'daily', label: 'Pago por día laboral' },
        { value: 'monthly', label: 'Pago mensual (2 quincenas)' },
      ];

      const currencyFormatter = new Intl.NumberFormat('es-CO', {
        style: 'currency',
        currency: 'COP',
        minimumFractionDigits: 0,
        maximumFractionDigits: 2,
      });

      const state = {
        metadata: null,
        calendarId: null,
        lastSummary: null,
        orderLocked: false,
        filters: {
          includeInactivePositions: false,
          includeInactiveOperators: false,
        },
        restFilters: {
          past: true,
          current: true,
          future: true,
        },
        editing: {
          positionId: null,
          operatorId: null,
          restOperatorId: null,
          restPeriodId: null,
        },
        lookups: {
          housesByFarm: new Map(),
          roomsByHouse: new Map(),
          operatorsById: new Map(),
          farmsById: new Map(),
          rolesById: new Map(),
          categoriesById: new Map(),
          shiftLabels: new Map(),
          alertLabels: new Map(),
          dayLabels: new Map(),
        restStatusLabels: new Map(),
        restSourceLabels: new Map(),
        positionsById: new Map(),
        positionLabels: new Map(),
        salaryPaymentTypes: new Map(),
      },
    };

      let pendingPositionDeleteId = null;
      let lastFocusedBeforeDeleteDialog = null;

      const formatPositionLabel = (position) => {
        if (!position) {
          return '';
        }
        const parts = [];
        if (position.name) {
          parts.push(position.name);
        } else if (position.id) {
          parts.push(`Posición ${position.id}`);
        }
        if (position.category?.name) {
          parts.push(position.category.name);
        }
        if (position.farm?.name) {
          parts.push(position.farm.name);
        }
        return parts.join(' · ');
      };

      const describeHandoffPosition = (position) => {
        if (!position) {
          return '';
        }
        const parts = [];
        if (position.name) {
          parts.push(position.name);
        }
        if (position.code) {
          parts.push(`#${position.code}`);
        }
        if (position.farm?.name) {
          parts.push(position.farm.name);
        }
        return parts.join(' · ');
      };

      const describeSalarySummary = (salary) => {
        if (!salary) {
          return 'Sin salario activo';
        }
        const paymentLabel =
          state.lookups.salaryPaymentTypes.get(salary.payment_type) ||
          salary.payment_type_label ||
          '';
        const rangeParts = [];
        if (salary.effective_from) {
          rangeParts.push(salary.effective_from);
        }
        if (salary.effective_until) {
          rangeParts.push(salary.effective_until);
        }
        const rangeLabel = rangeParts.length ? rangeParts.join(' → ') : '';
        return [formatCurrency(salary.amount), paymentLabel, rangeLabel].filter(Boolean).join(' · ');
      };

      const refreshPositionHighlight = () => {
        if (state.metadata && refs.positionsBody) {
          renderPositions();
        }
      };

      const refreshOperatorHighlight = () => {
        if (state.metadata && refs.operatorBody) {
          renderOperators();
        }
      };

      const setEditingPosition = (id) => {
        if (state.editing.positionId === id) {
          return;
        }
        state.editing.positionId = id;
        refreshPositionHighlight();
      };

      const setEditingOperator = (id) => {
        if (state.editing.operatorId === id) {
          return;
        }
        state.editing.operatorId = id;
        refreshOperatorHighlight();
      };

      const refs = {
        sections: Array.from(app.querySelectorAll('[data-step-index]')),
        navButtons: Array.from(app.querySelectorAll('[data-step-trigger]')),
        metadataStatus: app.querySelector('#metadata-status'),
        positionsBody: app.querySelector('#positions-body'),
        positionAddBtn: app.querySelector('#position-add-btn'),
        positionsRefreshBtn: app.querySelector('#refresh-metadata-btn'),
        positionIncludeInactive: app.querySelector('#position-include-inactive'),
        positionOrderStatus: app.querySelector('#position-order-status'),
        positionFormWrapper: app.querySelector('#position-form-wrapper'),
        positionForm: app.querySelector('#position-form'),
        positionMessage: app.querySelector('#position-form-message'),
        positionId: app.querySelector('#position-id'),
        positionDeleteDialog: app.querySelector('#position-delete-dialog'),
        positionDeleteCancel: app.querySelector('#position-delete-cancel'),
        positionDeleteConfirm: app.querySelector('#position-delete-confirm'),
        positionDeleteName: app.querySelector('[data-position-delete-name]'),
        positionName: app.querySelector('#position-name'),
        positionCodeDisplay: app.querySelector('#position-code-display'),
        positionCodeValue: app.querySelector('#position-code-value'),
        positionCategory: app.querySelector('#position-category'),
        positionFarm: app.querySelector('#position-farm'),
        positionHouse: app.querySelector('#position-house'),
        positionRooms: app.querySelector('#position-rooms'),
        positionHandoff: app.querySelector('#position-handoff'),
        positionValidFrom: app.querySelector('#position-valid-from'),
        positionValidUntil: app.querySelector('#position-valid-until'),
        positionCancelBtn: app.querySelector('#position-cancel-btn'),
        operatorCount: app.querySelector('#operator-count'),
        operatorBody: app.querySelector('#operator-body'),
        operatorSearch: app.querySelector('#operator-search'),
        operatorPositionFilter: app.querySelector('#operator-position-filter'),
        operatorIncludeInactive: app.querySelector('#operator-include-inactive'),
        operatorAddBtn: app.querySelector('#operator-add-btn'),
        operatorRefreshBtn: app.querySelector('#operator-refresh-btn'),
        operatorFormWrapper: app.querySelector('#operator-form-wrapper'),
        operatorForm: app.querySelector('#operator-form'),
        operatorMessage: app.querySelector('#operator-form-message'),
        operatorId: app.querySelector('#operator-id'),
        operatorDocument: app.querySelector('#operator-document'),
        operatorFirstName: app.querySelector('#operator-first-name'),
        operatorLastName: app.querySelector('#operator-last-name'),
        operatorPhone: app.querySelector('#operator-phone'),
        operatorAccessKey: app.querySelector('#operator-access-key'),
        operatorEmploymentStart: app.querySelector('#operator-employment-start'),
        operatorEmploymentEnd: app.querySelector('#operator-employment-end'),
        operatorRestDays: app.querySelector('#operator-rest-days'),
        operatorRoles: app.querySelector('#operator-roles'),
        operatorSuggestedPositions: app.querySelector('#operator-suggested-positions'),
        operatorSalaryList: app.querySelector('#operator-salary-list'),
        operatorSalaryAddBtn: app.querySelector('#operator-salary-add-btn'),
        operatorSalaryEmpty: app.querySelector('#operator-salary-empty'),
        operatorCancelBtn: app.querySelector('#operator-cancel-btn'),
        operatorRestAddBtn: app.querySelector('#operator-rest-add-btn'),
        operatorRestFilters: app.querySelector('#operator-rest-filters'),
        operatorRestList: app.querySelector('#operator-rest-list'),
        operatorRestEmptyHint: app.querySelector('#operator-rest-empty-hint'),
        operatorRestMessage: app.querySelector('#operator-rest-message'),
        operatorRestFormWrapper: app.querySelector('#operator-rest-form-wrapper'),
        operatorRestForm: app.querySelector('#operator-rest-form'),
        operatorRestId: app.querySelector('#operator-rest-id'),
        operatorRestOperator: app.querySelector('#operator-rest-operator'),
        operatorRestCalendar: app.querySelector('#operator-rest-calendar'),
        operatorRestStart: app.querySelector('#operator-rest-start'),
        operatorRestEnd: app.querySelector('#operator-rest-end'),
        operatorRestStatus: app.querySelector('#operator-rest-status'),
        operatorRestSource: app.querySelector('#operator-rest-source'),
        operatorRestNotes: app.querySelector('#operator-rest-notes'),
        operatorRestCalendarInfo: app.querySelector('#operator-rest-calendar-info'),
        operatorRestEditHint: app.querySelector('#operator-rest-edit-hint'),
        operatorRestCancelBtn: app.querySelector('#operator-rest-cancel-btn'),
        operatorRestSaveBtn: app.querySelector('#operator-rest-save-btn'),
        summaryPreview: app.querySelector('#summary-preview'),
        calendarFeedback: app.querySelector('#calendar-feedback'),
        reloadSummaryBtn: app.querySelector('#reload-summary-btn'),
        calendarActions: app.querySelector('#calendar-actions'),
        calendarDetailLink: app.querySelector('#open-calendar-detail'),
        generateCalendarBtn: document.getElementById('generate-calendar-btn'),
      };

      const openPositionDeleteDialog = (positionId) => {
        if (!refs.positionDeleteDialog) {
          return false;
        }
        pendingPositionDeleteId = positionId;
        const position = state.metadata?.positions?.find((item) => item.id === positionId);
        if (refs.positionDeleteName) {
          const label = formatPositionLabel(position);
          refs.positionDeleteName.textContent = label || '';
          if (label) {
            refs.positionDeleteName.classList.remove('hidden');
          } else {
            refs.positionDeleteName.classList.add('hidden');
          }
        }
        const activeElement = document.activeElement;
        lastFocusedBeforeDeleteDialog = activeElement instanceof HTMLElement ? activeElement : null;
        refs.positionDeleteDialog.classList.remove('hidden');
        window.setTimeout(() => {
          if (refs.positionDeleteConfirm && typeof refs.positionDeleteConfirm.focus === 'function') {
            refs.positionDeleteConfirm.focus();
          }
        }, 0);
        return true;
      };

      const closePositionDeleteDialog = () => {
        if (refs.positionDeleteDialog) {
          refs.positionDeleteDialog.classList.add('hidden');
        }
        if (refs.positionDeleteName) {
          refs.positionDeleteName.textContent = '';
          refs.positionDeleteName.classList.add('hidden');
        }
        pendingPositionDeleteId = null;
        const target = lastFocusedBeforeDeleteDialog;
        lastFocusedBeforeDeleteDialog = null;
        if (target && typeof target.focus === 'function') {
          target.focus();
        }
      };

      const availableSteps = new Set(
        refs.sections
          .map((section) => Number(section.getAttribute('data-step-index')))
          .filter((value) => !Number.isNaN(value))
      );
      const sortedSteps = Array.from(availableSteps).sort((a, b) => a - b);
      const stepSlugMap = view === 'configurator'
        ? { 1: 'positions', 2: 'collaborators' }
        : {};
      const slugToStep = new Map(
        Object.entries(stepSlugMap).map(([step, slug]) => [slug, Number(step)])
      );
      if (view === 'configurator') {
        slugToStep.set('position', 1);
        slugToStep.set('posiciones', 1);
        slugToStep.set('collaboradores', 2);
        slugToStep.set('rules', 2);
        slugToStep.set('reglas', 2);
        slugToStep.set('draft', 2);
        slugToStep.set('borrador', 2);
      }
      if (refs.positionIncludeInactive) {
        state.filters.includeInactivePositions = refs.positionIncludeInactive.checked;
      }
      if (refs.operatorIncludeInactive) {
        state.filters.includeInactiveOperators = refs.operatorIncludeInactive.checked;
      }

      const toneClassSets = {
        info: ['border-slate-200', 'bg-slate-50', 'text-slate-600'],
        success: ['border-emerald-200', 'bg-emerald-50', 'text-emerald-700'],
        error: ['border-red-200', 'bg-red-50', 'text-red-700'],
        warning: ['border-amber-200', 'bg-amber-50', 'text-amber-700'],
      };
      const allToneClasses = Object.values(toneClassSets).flat();

      const escapeHtml = (value) => {
        if (value === null || value === undefined) {
          return '';
        }
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };

      const getRestDayInputs = () => {
        if (!refs.operatorRestDays) {
          return [];
        }
        return Array.from(refs.operatorRestDays.querySelectorAll('input[type="checkbox"]'));
      };

      const getSelectedRestDays = () => {
        return getRestDayInputs()
          .filter((input) => input.checked)
          .map((input) => Number.parseInt(input.value, 10))
          .filter((value) => Number.isFinite(value));
      };

      const setSelectedRestDays = (values) => {
        const selected = new Set((values || []).map((value) => String(value)));
        getRestDayInputs().forEach((input) => {
          input.checked = selected.has(input.value);
        });
      };

      const renderRestDayOptions = () => {
        if (!refs.operatorRestDays) {
          return;
        }
        const choices = state.metadata?.choice_sets?.days_of_week || [];
        if (!choices.length) {
          refs.operatorRestDays.innerHTML =
            '<p class="rounded border border-slate-200 bg-white px-3 py-2 text-xs text-slate-500">No hay días configurados. Revisa la configuración del calendario.</p>';
          return;
        }
        const previousSelection = getSelectedRestDays();
        refs.operatorRestDays.innerHTML = choices
          .map((choice) => {
            const value = escapeHtml(String(choice.value));
            const label = escapeHtml(choice.label);
            return `<label class="inline-flex items-center gap-2 rounded border border-slate-200 bg-white px-3 py-1 text-sm text-slate-700 shadow-sm">
              <input type="checkbox" value="${value}" class="h-4 w-4 rounded border-slate-300 text-brand focus:ring-brand" />
              <span>${label}</span>
            </label>`;
          })
          .join('');
        setSelectedRestDays(previousSelection);
      };

      const formatDateLabel = (isoDate) => {
        if (!isoDate) {
          return '';
        }
        const parts = String(isoDate).split('-');
        if (parts.length !== 3) {
          return isoDate;
        }
        const [year, month, day] = parts;
        if (!year || !month || !day) {
          return isoDate;
        }
        return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
      };

      const restFilterActiveClasses = ['border-amber-400', 'bg-amber-50', 'text-amber-700', 'hover:bg-amber-100'];
      const restFilterInactiveClasses = ['border-slate-300', 'text-slate-600', 'hover:bg-slate-100'];

      const syncRestFiltersUI = () => {
        if (!refs.operatorRestFilters) {
          return;
        }
        refs.operatorRestFilters.querySelectorAll('.rest-filter-btn').forEach((button) => {
          const key = button.dataset.filter;
          if (!key) {
            return;
          }
          const active = Boolean(state.restFilters[key]);
          button.dataset.active = active ? 'true' : 'false';
          button.classList.remove(...restFilterActiveClasses, ...restFilterInactiveClasses);
          if (active) {
            button.classList.add(...restFilterActiveClasses);
          } else {
            button.classList.add(...restFilterInactiveClasses);
          }
        });
      };

      const normalizeIsoDate = (isoDate) => {
        if (!isoDate) {
          return null;
        }
        const parts = String(isoDate).split('-').map((value) => Number.parseInt(value, 10));
        if (parts.length !== 3 || parts.some((value) => Number.isNaN(value))) {
          return null;
        }
        const [year, month, day] = parts;
        return new Date(year, month - 1, day);
      };

      const getToday = () => {
        const now = new Date();
        return new Date(now.getFullYear(), now.getMonth(), now.getDate());
      };

      const classifyRestPeriod = (period) => {
        const startDate = normalizeIsoDate(period.start);
        const endDate = normalizeIsoDate(period.end);
        const today = getToday();
        if (!startDate || !endDate) {
          return {
            isPast: false,
            isCurrent: false,
            isFuture: false,
          };
        }
        const isPast = endDate < today;
        const isFuture = startDate > today;
        const isCurrent = !isPast && !isFuture;
        return {
          isPast,
          isCurrent,
          isFuture,
        };
      };

      const matchesRestFilters = (period) => {
        const filters = state.restFilters;
        const classification = classifyRestPeriod(period);
        const typeFiltersActive = filters.past || filters.current || filters.future;
        const typeMatch =
          (filters.past && classification.isPast) ||
          (filters.current && classification.isCurrent) ||
          (filters.future && classification.isFuture);
        if (typeFiltersActive && !typeMatch) {
          return false;
        }
        return true;
      };

      const getRestPeriodsForOperator = (operatorId) => {
        if (!state.metadata || !operatorId) {
          return [];
        }
        return (state.metadata.rest_periods || []).filter((period) => period.operator_id === operatorId);
      };

      const getRestPeriodById = (restId) => {
        if (!state.metadata || !restId) {
          return null;
        }
        return (state.metadata.rest_periods || []).find((period) => period.id === restId) || null;
      };

      const formatRestRange = (period) => {
        const startLabel = formatDateLabel(period.start);
        const endLabel = formatDateLabel(period.end);
        if (startLabel === endLabel) {
          return startLabel;
        }
        return `${startLabel} → ${endLabel}`;
      };

      const formatDateTimeLabel = (isoDateTime) => {
        if (!isoDateTime) {
          return '';
        }
        const [datePart] = String(isoDateTime).split('T');
        return formatDateLabel(datePart);
      };

      const describeRestClassification = (period) => {
        const classification = classifyRestPeriod(period);
        if (classification.isCurrent) {
          return 'En curso';
        }
        if (classification.isFuture) {
          return 'Próximo';
        }
        if (classification.isPast) {
          return 'Histórico';
        }
        return '';
      };

      const sortRestPeriods = (periods) =>
        [...periods].sort((a, b) => {
          const aStart = normalizeIsoDate(a.start);
          const bStart = normalizeIsoDate(b.start);
          if (aStart && bStart && aStart.getTime() !== bStart.getTime()) {
            return bStart.getTime() - aStart.getTime();
          }
          const aEnd = normalizeIsoDate(a.end);
          const bEnd = normalizeIsoDate(b.end);
          if (aEnd && bEnd && aEnd.getTime() !== bEnd.getTime()) {
            return bEnd.getTime() - aEnd.getTime();
          }
          return (b.id || 0) - (a.id || 0);
        });

      const getDefaultRestStatus = () => {
        const statuses = state.metadata?.choice_sets?.rest_statuses || [];
        const planned = statuses.find((choice) => choice.value === 'planned');
        return planned?.value || (statuses[0]?.value || '');
      };

      const getDefaultRestSource = () => {
        const sources = state.metadata?.choice_sets?.rest_sources || [];
        const manual = sources.find((choice) => choice.value === 'manual');
        return manual?.value || (sources[0]?.value || '');
      };

      const renderOperatorRestList = (operatorId) => {
        if (!refs.operatorRestList) {
          return;
        }
        if (!operatorId) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-slate-200 bg-slate-50 px-4 py-3 text-slate-500">Selecciona un colaborador guardado para revisar sus descansos.</p>';
          return;
        }
        const periods = getRestPeriodsForOperator(operatorId);
        if (!periods.length) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-slate-200 bg-slate-50 px-4 py-3 text-slate-500">No hay descansos registrados para este colaborador.</p>';
          return;
        }
        const filtered = periods.filter(matchesRestFilters);
        if (!filtered.length) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-amber-200 bg-amber-50 px-4 py-3 text-amber-700">No hay descansos que coincidan con los filtros seleccionados.</p>';
          return;
        }

        const badgeBase = 'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold';

        refs.operatorRestList.innerHTML = sortRestPeriods(filtered)
          .map((period) => {
            const statusLabel =
              state.lookups.restStatusLabels.get(period.status) || period.status_label || period.status || '';
            const sourceLabel =
              state.lookups.restSourceLabels.get(period.source) || period.source_label || period.source || '';
            const classificationLabel = describeRestClassification(period);
            const durationDays = Number.parseInt(period.duration_days, 10);
            const durationLabel =
              Number.isFinite(durationDays) && durationDays > 0
                ? `${durationDays} día${durationDays === 1 ? '' : 's'}`
                : '';
            const isSystem = Boolean(period.is_system_generated);
            const containerClasses = [
              'rounded',
              'border',
              'px-4',
              'py-3',
              'text-sm',
              'bg-white',
              'shadow-sm',
              'space-y-2',
            ];
            if (isSystem) {
              containerClasses.push('border-amber-300', 'bg-amber-50/70');
            } else {
              containerClasses.push('border-slate-200');
            }
            const statusBadge = statusLabel
              ? `<span class="${badgeBase} bg-emerald-100 text-emerald-700">${escapeHtml(statusLabel)}</span>`
              : '';
            const sourceBadge = sourceLabel
              ? `<span class="${badgeBase} ${
                  isSystem ? 'bg-amber-200 text-amber-800' : 'bg-slate-200 text-slate-600'
                }">${escapeHtml(sourceLabel)}</span>`
              : '';
            const classificationBadge = classificationLabel
              ? `<span class="${badgeBase} bg-indigo-100 text-indigo-700">${escapeHtml(classificationLabel)}</span>`
              : '';
            const durationBadge = durationLabel
              ? `<span class="${badgeBase} bg-slate-100 text-slate-600">${escapeHtml(durationLabel)}</span>`
              : '';
            const notesLine = period.notes
              ? `<p class="text-xs text-slate-600">Notas: ${escapeHtml(period.notes)}</p>`
              : '';
            const calendarLine = period.calendar
              ? `<p class="text-xs text-slate-600">Calendario origen: <span class="font-medium text-slate-700">${escapeHtml(
                  period.calendar.name || `#${period.calendar.id}`,
                )}</span> (${formatDateLabel(period.calendar.start_date)} → ${formatDateLabel(
                  period.calendar.end_date,
                )})</p>`
              : '';
            const createdLine = period.created_by
              ? `<p class="text-[11px] text-slate-400">Registrado por ${escapeHtml(
                  period.created_by.name || '',
                )} el ${escapeHtml(formatDateTimeLabel(period.created_at) || '')}</p>`
              : '';

            return `
              <div class="${containerClasses.join(' ')}" data-rest-id="${period.id}">
                <div class="flex flex-wrap items-start justify-between gap-3">
                  <div>
                    <p class="font-semibold text-slate-800">${escapeHtml(formatRestRange(period))}</p>
                    <div class="mt-1 flex flex-wrap gap-2">
                      ${statusBadge}
                      ${sourceBadge}
                      ${classificationBadge}
                      ${durationBadge}
                    </div>
                    ${notesLine}
                    ${calendarLine}
                    ${createdLine}
                  </div>
                  <div class="flex flex-wrap gap-2">
                    <button type="button" data-action="rest-edit" data-id="${period.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                    <button type="button" data-action="rest-delete" data-id="${period.id}" class="rounded border border-red-200 px-2 py-1 text-xs text-red-700 hover:bg-red-50">Eliminar</button>
                  </div>
                </div>
              </div>
            `;
          })
          .join('');
      };

      const setOperatorRestContext = (operatorId) => {
        state.editing.restOperatorId = operatorId || null;
        state.editing.restPeriodId = null;
        if (refs.operatorRestAddBtn) {
          const hasOperator = Boolean(operatorId);
          refs.operatorRestAddBtn.disabled = !hasOperator;
          refs.operatorRestAddBtn.classList.toggle('opacity-50', !hasOperator);
          refs.operatorRestAddBtn.classList.toggle('cursor-not-allowed', !hasOperator);
        }
        if (refs.operatorRestEmptyHint) {
          refs.operatorRestEmptyHint.classList.toggle('hidden', Boolean(operatorId));
        }
        toggleWrapper(refs.operatorRestFormWrapper, false);
        setFormMessage(refs.operatorRestMessage, '');
        renderOperatorRestList(operatorId);
      };

      const closeRestForm = () => {
        resetForm(refs.operatorRestForm, refs.operatorRestMessage);
        state.editing.restPeriodId = null;
        if (refs.operatorRestId) {
          refs.operatorRestId.value = '';
        }
        if (refs.operatorRestCalendarInfo) {
          refs.operatorRestCalendarInfo.classList.add('hidden');
          refs.operatorRestCalendarInfo.textContent = '';
        }
        if (refs.operatorRestEditHint) {
          refs.operatorRestEditHint.textContent = '';
        }
        toggleWrapper(refs.operatorRestFormWrapper, false);
      };

      const populateRestForm = (period = null) => {
        if (!refs.operatorRestForm) {
          return;
        }
        setFormMessage(refs.operatorRestMessage, '');
        if (refs.operatorRestId) {
          refs.operatorRestId.value = period?.id ? String(period.id) : '';
        }
        if (refs.operatorRestOperator) {
          const operatorId = period?.operator_id || state.editing.restOperatorId;
          refs.operatorRestOperator.value = operatorId ? String(operatorId) : '';
        }
        if (refs.operatorRestCalendar) {
          refs.operatorRestCalendar.value = period?.calendar_id ? String(period.calendar_id) : '';
        }
        if (refs.operatorRestStart) {
          refs.operatorRestStart.value = period?.start || '';
        }
        if (refs.operatorRestEnd) {
          refs.operatorRestEnd.value = period?.end || '';
        }
        if (refs.operatorRestStatus) {
          refs.operatorRestStatus.value = period?.status || getDefaultRestStatus() || '';
        }
        if (refs.operatorRestSource) {
          refs.operatorRestSource.value = period?.source || getDefaultRestSource() || '';
        }
        if (refs.operatorRestNotes) {
          refs.operatorRestNotes.value = period?.notes || '';
        }
        if (refs.operatorRestCalendarInfo) {
          if (period?.calendar) {
            const calendarText = `Calendario origen: ${period.calendar.name || `#${period.calendar.id}`} (${formatDateLabel(
              period.calendar.start_date,
            )} → ${formatDateLabel(period.calendar.end_date)})`;
            refs.operatorRestCalendarInfo.textContent = calendarText;
            refs.operatorRestCalendarInfo.classList.remove('hidden');
          } else {
            refs.operatorRestCalendarInfo.textContent = '';
            refs.operatorRestCalendarInfo.classList.add('hidden');
          }
        }
        if (refs.operatorRestEditHint) {
          const hintParts = [
            'Los descansos impactan la planificación de turnos.',
            'Confirma la operación dos veces antes de guardar.',
          ];
          if (period?.is_system_generated) {
            hintParts.push('Este descanso proviene de un calendario generado automáticamente.');
          }
          refs.operatorRestEditHint.textContent = hintParts.join(' ');
        }
      };

      const openRestForm = (period = null) => {
        const operatorId = period?.operator_id || state.editing.restOperatorId;
        if (!operatorId) {
          updateMetadataStatus('Primero debes guardar al colaborador para gestionar descansos.', 'warning');
          return;
        }
        state.editing.restPeriodId = period?.id || null;
        populateRestForm(period);
        toggleWrapper(refs.operatorRestFormWrapper, true);
        focusWrapper(refs.operatorRestFormWrapper, refs.operatorRestStart);
      };

      const buildRestPayload = () => {
        const operatorValue = refs.operatorRestOperator?.value || '';
        const payload = {
          operator: operatorValue ? Number(operatorValue) : null,
          start_date: refs.operatorRestStart?.value || '',
          end_date: refs.operatorRestEnd?.value || '',
          status: refs.operatorRestStatus?.value || '',
          source: refs.operatorRestSource?.value || '',
          notes: refs.operatorRestNotes?.value?.trim() || '',
        };
        const calendarValue = refs.operatorRestCalendar?.value || '';
        if (calendarValue) {
          payload.calendar = Number(calendarValue);
        } else {
          payload.calendar = null;
        }
        return payload;
      };

      const confirmRestAction = (message) => {
        const firstMessage =
          message ||
          'Vas a modificar un descanso. Esta acción puede impactar las asignaciones existentes y las reglas configuradas.';
        const first = window.confirm(`${firstMessage}\n\n¿Deseas continuar?`);
        if (!first) {
          return false;
        }
        const second = window.confirm('Confirma nuevamente para aplicar el cambio en los descansos.');
        return second;
      };

      const persistRestPeriod = async (payload, { id = null, successMessage } = {}) => {
        if (!API.restPeriods) {
          return;
        }
        const url = id && API.restPeriodDetailTemplate ? replaceId(API.restPeriodDetailTemplate, id) : API.restPeriods;
        const method = id ? 'PATCH' : 'POST';
        setFormMessage(refs.operatorRestMessage, 'Guardando descanso…', 'info');
        try {
          const response = await apiRequest(url, { method, body: payload });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              const errorMessage = data?.error || 'No fue posible guardar el descanso.';
              setFormMessage(refs.operatorRestMessage, errorMessage, 'error');
            } else {
              const text = await response.text();
              setFormMessage(refs.operatorRestMessage, text || 'No fue posible guardar el descanso.', 'error');
            }
            return;
          }
          const data = await response.json();
          setFormMessage(refs.operatorRestMessage, successMessage || 'Descanso guardado correctamente.', 'success');
          if (data?.requires_calendar_refresh) {
            updateMetadataStatus(
              'Los cambios en descansos pueden requerir actualizar o recrear el calendario.',
              'warning',
            );
          } else {
            updateMetadataStatus('Información actualizada.', 'success');
          }
          closeRestForm();
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          setFormMessage(refs.operatorRestMessage, 'Error al guardar el descanso. Intenta nuevamente.', 'error');
        }
      };

      const deleteRestPeriod = async (period) => {
        if (!API.restPeriodDetailTemplate) {
          return;
        }
        const url = replaceId(API.restPeriodDetailTemplate, period.id);
        try {
          const response = await apiRequest(url, { method: 'DELETE' });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              updateMetadataStatus(data?.error || 'No fue posible eliminar el descanso.', 'error');
            } else {
              const text = await response.text();
              updateMetadataStatus(text || 'No fue posible eliminar el descanso.', 'error');
            }
            return;
          }
          const data = await response.json();
          if (data?.requires_calendar_refresh) {
            updateMetadataStatus(
              'Se eliminó el descanso. Recuerda actualizar o recrear el calendario para reflejar los cambios.',
              'warning',
            );
          } else {
            updateMetadataStatus('Descanso eliminado correctamente.', 'success');
          }
          if (state.editing.restPeriodId === period.id) {
            closeRestForm();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error eliminando el descanso. Intenta nuevamente.', 'error');
        }
      };

      const replaceId = (template, id) => template.replace('/0/', `/${id}/`);

      const setFormMessage = (element, message = '', tone = 'info') => {
        if (!element) {
          return;
        }
        if (!message) {
          element.classList.add('hidden');
          element.textContent = '';
          return;
        }
        element.classList.remove('hidden');
        element.classList.remove(...allToneClasses);
        const classes = toneClassSets[tone] || toneClassSets.info;
        element.classList.add(...classes);
        element.textContent = message;
      };

      const updateMetadataStatus = (message, tone = 'info') => {
        setFormMessage(refs.metadataStatus, message, tone);
      };

      const toggleWrapper = (wrapper, visible) => {
        if (!wrapper) {
          return;
        }
        wrapper.classList.toggle('hidden', !visible);
      };

      const focusableSelector =
        'input:not([type="hidden"]):not([disabled]):not([readonly]), select:not([disabled]), textarea:not([disabled])';

      const focusWrapper = (wrapper, preferred = null) => {
        if (!wrapper) {
          return;
        }
        requestAnimationFrame(() => {
          wrapper.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
          const target = preferred || wrapper.querySelector(focusableSelector);
          if (target && typeof target.focus === 'function') {
            try {
              target.focus({ preventScroll: true });
            } catch (error) {
              target.focus();
            }
          }
        });
      };

      const resetForm = (form, messageEl) => {
        if (form) {
          if (typeof form.reset === 'function') {
            form.reset();
          } else {
            form.querySelectorAll('input, select, textarea').forEach((field) => {
              const tag = field.tagName.toLowerCase();
              if (tag === 'input') {
                const input = field;
                if (input.type === 'checkbox' || input.type === 'radio') {
                  input.checked = false;
                } else {
                  input.value = '';
                }
              } else if (tag === 'select') {
                const select = field;
                if ('options' in select && 'selectedIndex' in select) {
                  select.selectedIndex = select.options.length ? 0 : -1;
                }
              } else if (tag === 'textarea') {
                const textarea = field;
                textarea.value = '';
              }
            });
          }
        }
        if (messageEl) {
          setFormMessage(messageEl, '');
        }
      };

      const formatCurrency = (value) => {
        const amount = Number(value);
        if (!Number.isFinite(amount)) {
          return value || '';
        }
        return currencyFormatter.format(amount);
      };

      const getSalaryPaymentOptions = () => {
        const options = state.metadata?.choice_sets?.salary_payment_types;
        if (Array.isArray(options) && options.length) {
          return options;
        }
        return DEFAULT_SALARY_PAYMENT_TYPES;
      };

      const getDefaultSalaryPaymentType = () => {
        const options = getSalaryPaymentOptions();
        const monthlyOption = options.find((option) => option.value === 'monthly');
        if (monthlyOption) {
          return monthlyOption.value;
        }
        return options[0]?.value || '';
      };

      const clearSalaryRows = () => {
        if (refs.operatorSalaryList) {
          refs.operatorSalaryList.innerHTML = '';
        }
        updateSalaryEmptyHint();
      };

      const updateSalaryEmptyHint = () => {
        if (!refs.operatorSalaryEmpty) {
          return;
        }
        const hasRows = Boolean(refs.operatorSalaryList?.querySelector('[data-salary-row]'));
        refs.operatorSalaryEmpty.classList.toggle('hidden', hasRows);
      };

      const createSalaryRow = (data = {}) => {
        const resolved = { ...data };
        if (!resolved.effective_from) {
          const today = new Date().toISOString().slice(0, 10);
          resolved.effective_from = refs.operatorEmploymentStart?.value || today;
        }
        const fallbackPayment = getDefaultSalaryPaymentType();
        if (!resolved.payment_type && fallbackPayment) {
          resolved.payment_type = fallbackPayment;
        }

        const wrapper = document.createElement('div');
        wrapper.className = 'grid gap-3 rounded border border-slate-200 bg-white p-3 text-sm md:grid-cols-5';
        wrapper.setAttribute('data-salary-row', 'true');

        const idInput = document.createElement('input');
        idInput.type = 'hidden';
        idInput.value = resolved.id ? String(resolved.id) : '';
        idInput.setAttribute('data-salary-id', 'true');
        wrapper.append(idInput);

        const buildField = (labelText, element) => {
          const label = document.createElement('label');
          label.className = 'flex flex-col text-xs font-medium text-slate-600';
          label.textContent = labelText;
          element.className =
            'mt-1 rounded border border-slate-300 px-3 py-2 text-sm focus:border-brand focus:outline-none focus:ring-1 focus:ring-brand';
          label.append(element);
          return label;
        };

        const startInput = document.createElement('input');
        startInput.type = 'date';
        startInput.value = resolved.effective_from || '';
        startInput.setAttribute('data-salary-start', 'true');
        wrapper.append(buildField('Fecha de inicio', startInput));

        const endInput = document.createElement('input');
        endInput.type = 'date';
        endInput.value = resolved.effective_until || '';
        endInput.setAttribute('data-salary-end', 'true');
        wrapper.append(buildField('Fecha de fin (opcional)', endInput));

        const amountInput = document.createElement('input');
        amountInput.type = 'number';
        amountInput.min = '0';
        amountInput.step = '0.01';
        amountInput.placeholder = '0';
        amountInput.value = resolved.amount ? String(resolved.amount) : '';
        amountInput.setAttribute('data-salary-amount', 'true');
        wrapper.append(buildField('Monto (COP)', amountInput));

        const paymentSelect = document.createElement('select');
        paymentSelect.setAttribute('data-salary-type', 'true');
        const paymentOptions = getSalaryPaymentOptions();
        paymentOptions.forEach((option) => {
          const opt = document.createElement('option');
          opt.value = option.value;
          opt.textContent = option.label;
          paymentSelect.append(opt);
        });
        if (resolved.payment_type) {
          paymentSelect.value = resolved.payment_type;
        }
        wrapper.append(buildField('Esquema de pago', paymentSelect));

        const actions = document.createElement('div');
        actions.className = 'flex flex-col items-start gap-2';
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className =
          'inline-flex items-center rounded border border-red-200 px-3 py-1 text-xs font-semibold text-red-600 hover:bg-red-50';
        removeBtn.dataset.action = 'salary-remove';
        removeBtn.textContent = 'Quitar';
        actions.append(removeBtn);
        if (resolved.is_active) {
          const badge = document.createElement('span');
          badge.className =
            'inline-flex items-center rounded-full bg-emerald-100 px-2 py-0.5 text-[11px] font-semibold uppercase tracking-wide text-emerald-700';
          badge.textContent = 'Vigente';
          actions.append(badge);
        }
        wrapper.append(actions);

        return wrapper;
      };

      const addSalaryRow = (data = {}, { atStart = false } = {}) => {
        if (!refs.operatorSalaryList) {
          return;
        }
        const row = createSalaryRow(data);
        if (atStart && refs.operatorSalaryList.firstChild) {
          refs.operatorSalaryList.prepend(row);
        } else {
          refs.operatorSalaryList.append(row);
        }
        updateSalaryEmptyHint();
      };

      const setSalaryRows = (rows = []) => {
        clearSalaryRows();
        if (Array.isArray(rows) && rows.length) {
          rows.forEach((entry) => addSalaryRow(entry));
        } else {
          addSalaryRow({}, { atStart: true });
        }
      };

      const getSalaryEntriesFromDom = () => {
        if (!refs.operatorSalaryList) {
          return [];
        }
        return Array.from(refs.operatorSalaryList.querySelectorAll('[data-salary-row]')).map((row) => {
          const idValue = row.querySelector('[data-salary-id]')?.value?.trim();
          const amountValue = row.querySelector('[data-salary-amount]')?.value?.trim() || '';
          const startValue = row.querySelector('[data-salary-start]')?.value?.trim() || '';
          const endValue = row.querySelector('[data-salary-end]')?.value?.trim() || '';
          const typeValue = row.querySelector('[data-salary-type]')?.value || '';
          let identifier = null;
          if (idValue) {
            const parsed = Number.parseInt(idValue, 10);
            identifier = Number.isNaN(parsed) ? null : parsed;
          }
          return {
            id: identifier,
            amount: amountValue,
            effective_from: startValue,
            effective_until: endValue,
            payment_type: typeValue,
          };
        });
      };

      const csrfSafeMethods = new Set(['GET', 'HEAD', 'OPTIONS', 'TRACE']);

      const getCookie = (name) => {
        if (typeof document === 'undefined') {
          return '';
        }
        const cookies = document.cookie ? document.cookie.split('; ') : [];
        for (const cookie of cookies) {
          if (cookie.startsWith(`${name}=`)) {
            return decodeURIComponent(cookie.slice(name.length + 1));
          }
        }
        return '';
      };

      const getCsrfToken = () => getCookie('csrftoken');

      const apiRequest = (url, { method = 'GET', body } = {}) => {
        const upperMethod = (method || 'GET').toUpperCase();
        const headers = { 'X-Requested-With': 'XMLHttpRequest' };
        if (!csrfSafeMethods.has(upperMethod)) {
          const token = getCsrfToken();
          if (token) {
            headers['X-CSRFToken'] = token;
          }
        }
        const options = {
          method: upperMethod,
          headers,
        };
        options.credentials = 'same-origin';
        if (body !== undefined) {
          options.body = JSON.stringify(body);
          options.headers['Content-Type'] = 'application/json';
        }
        return fetch(url, options);
      };

      const populateSelect = (
        select,
        items,
        {
          valueKey = 'value',
          labelKey = 'label',
          includeBlank = true,
          blankLabel = 'Seleccione…',
          keepValue = true,
          selectedValues = null,
        } = {}
      ) => {
        if (!select) {
          return;
        }
        const isMultiple = Boolean(select.multiple);
        const previousValues = keepValue
          ? Array.from(select.selectedOptions || []).map((option) => option.value)
          : [];
        select.innerHTML = '';
        if (includeBlank && !isMultiple) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = blankLabel;
          select.append(option);
        }
        const selectedSet = new Set(
          (selectedValues ?? (keepValue ? previousValues : [])).map((value) => String(value))
        );
        (items || []).forEach((item) => {
          const value = String(item[valueKey]);
          const option = document.createElement('option');
          option.value = value;
          option.textContent = item[labelKey];
          if (selectedSet.has(value)) {
            option.selected = true;
          }
          select.append(option);
        });
        if (!isMultiple) {
          const targetValue =
            selectedValues && selectedValues.length
              ? String(selectedValues[0])
              : keepValue && previousValues.length
              ? String(previousValues[0])
              : '';
          if (targetValue) {
            select.value = targetValue;
          } else if (!includeBlank && select.options.length) {
            select.selectedIndex = 0;
          }
        }
      };

      const rebuildLookups = () => {
        if (!state.metadata || state.orderLocked) {
          return;
        }

        const housesByFarm = new Map();
        state.metadata.chicken_houses.forEach((house) => {
          const list = housesByFarm.get(house.farm_id) || [];
          list.push(house);
          housesByFarm.set(house.farm_id, list);
        });
        housesByFarm.forEach((list) => list.sort((a, b) => a.name.localeCompare(b.name)));

        const roomsByHouse = new Map();
        state.metadata.rooms.forEach((room) => {
          const list = roomsByHouse.get(room.chicken_house_id) || [];
          list.push(room);
          roomsByHouse.set(room.chicken_house_id, list);
        });
        roomsByHouse.forEach((list) => list.sort((a, b) => a.name.localeCompare(b.name)));

        const operatorsById = new Map();
        state.metadata.operators.forEach((operator) => {
          operatorsById.set(operator.id, operator);
        });

        const farmsById = new Map();
        state.metadata.farms.forEach((farm) => {
          farmsById.set(farm.id, farm);
        });

        const rolesById = new Map();
        state.metadata.roles.forEach((role) => {
          rolesById.set(role.id, role);
        });

        const categoriesById = new Map();
        (state.metadata.categories || []).forEach((category) => {
          categoriesById.set(String(category.id), category);
        });

        const positionsById = new Map();
        (state.metadata.positions || []).forEach((position) => {
          positionsById.set(Number(position.id), position);
        });

        const positionLabels = new Map();
        positionsById.forEach((position, id) => {
          positionLabels.set(String(id), formatPositionLabel(position));
        });

        const choiceMap = (choices) => {
          const map = new Map();
          choices.forEach((choice) => {
            map.set(choice.value, choice.label);
          });
          return map;
        };

        state.lookups = {
          housesByFarm,
          roomsByHouse,
          operatorsById,
          farmsById,
          rolesById,
          categoriesById,
          positionsById,
          positionLabels,
          shiftLabels: choiceMap(state.metadata.choice_sets.shift_types),
          alertLabels: choiceMap(state.metadata.choice_sets.alert_levels),
          dayLabels: choiceMap(state.metadata.choice_sets.days_of_week),
          restStatusLabels: choiceMap(state.metadata.choice_sets.rest_statuses || []),
          restSourceLabels: choiceMap(state.metadata.choice_sets.rest_sources || []),
          salaryPaymentTypes: choiceMap(state.metadata.choice_sets.salary_payment_types || []),
        };
      };

      const updateRoomOptions = (houseId, { selectedRooms = [], keepValue = true } = {}) => {
        if (!refs.positionRooms) {
          return;
        }
        if (!houseId) {
          populateSelect(refs.positionRooms, [], { includeBlank: false, keepValue: false, selectedValues: [] });
          return;
        }
        const rooms = state.lookups.roomsByHouse.get(Number(houseId)) || [];
        populateSelect(refs.positionRooms, rooms, {
          valueKey: 'id',
          labelKey: 'name',
          includeBlank: false,
          keepValue,
          selectedValues: selectedRooms,
        });
      };

      const updateHouseOptions = (farmId, { selectedHouse = '', selectedRooms = [], keepValue = true } = {}) => {
        if (!refs.positionHouse) {
          return;
        }
        const houses = state.lookups.housesByFarm.get(Number(farmId)) || [];
        const selectedValues = selectedHouse ? [selectedHouse] : keepValue ? [refs.positionHouse.value] : [];
        populateSelect(refs.positionHouse, houses, {
          valueKey: 'id',
          labelKey: 'name',
          includeBlank: true,
          blankLabel: 'Todos los galpones',
          keepValue: false,
          selectedValues,
        });
        const currentHouse = selectedValues[0] || '';
        if (selectedHouse) {
          refs.positionHouse.value = selectedHouse;
        } else if (!keepValue) {
          refs.positionHouse.value = '';
        } else {
          refs.positionHouse.value = currentHouse;
        }
        const effectiveHouse = refs.positionHouse.value || '';
        updateRoomOptions(effectiveHouse, { selectedRooms, keepValue: false });
      };

      const updateHandoffOptions = (
        {
          excludeId = null,
          selected = '',
          fallbackPosition = null,
          keepValue = true,
          farmId = null,
        } = {}
      ) => {
        if (!refs.positionHandoff) {
          return;
        }
        const selectedValue = selected ? String(selected) : '';
        const targetFarm =
          farmId !== null && farmId !== undefined && farmId !== '' ? String(farmId) : '';
        const positions = Array.isArray(state.metadata?.positions) ? state.metadata.positions : [];
        const items = positions
          .filter((item) =>
            excludeId == null ? true : Number(item.id) !== Number(excludeId)
          )
          .filter((item) => {
            if (!targetFarm) {
              return true;
            }
            const itemFarmId = item.farm?.id ? String(item.farm.id) : '';
            return itemFarmId === targetFarm;
          })
          .map((item) => {
            const label =
              formatPositionLabel(item) ||
              describeHandoffPosition(item) ||
              `Posición ${item.id}`;
            return {
              value: String(item.id),
              label,
            };
          });
        if (
          selectedValue &&
          !items.some((item) => item.value === selectedValue) &&
          fallbackPosition
        ) {
          const fallbackLabel =
            describeHandoffPosition(fallbackPosition) || `Posición ${selectedValue}`;
          items.unshift({
            value: selectedValue,
            label: fallbackLabel,
          });
        }
        populateSelect(refs.positionHandoff, items, {
          includeBlank: true,
          blankLabel: 'Sin entrega asignada',
          keepValue,
          selectedValues: selectedValue ? [selectedValue] : [],
        });
      };

      const populateStaticOptions = () => {
        if (!state.metadata || state.orderLocked) {
          return;
        }

        populateSelect(refs.positionCategory, state.metadata.choice_sets.position_categories, { blankLabel: 'Selecciona categoría' });
        populateSelect(refs.positionFarm, state.metadata.farms, { valueKey: 'id', labelKey: 'name', blankLabel: 'Selecciona granja' });
        const currentFarm = refs.positionFarm?.value || '';
        const selectedHandoff = refs.positionHandoff?.value || '';
        updateHandoffOptions({
          farmId: currentFarm,
          selected: selectedHandoff,
          excludeId: state.editing.positionId,
        });

        populateSelect(refs.operatorRoles, state.metadata.roles, { valueKey: 'id', labelKey: 'label', includeBlank: false, keepValue: false });
        if (refs.operatorSuggestedPositions) {
          const suggestedOptions = (state.metadata.positions || []).map((position) => ({
            value: String(position.id),
            label: formatPositionLabel(position),
          }));
          populateSelect(refs.operatorSuggestedPositions, suggestedOptions, {
            valueKey: 'value',
            labelKey: 'label',
            includeBlank: false,
            keepValue: true,
          });
        }
        populateSelect(refs.operatorRestStatus, state.metadata.choice_sets.rest_statuses || [], {
          blankLabel: 'Selecciona estado',
          keepValue: true,
        });
        populateSelect(refs.operatorRestSource, state.metadata.choice_sets.rest_sources || [], {
          blankLabel: 'Selecciona origen',
          keepValue: true,
        });

        updateHouseOptions(currentFarm);
      };

      const getPositionPayload = () => ({
        name: refs.positionName?.value.trim() || '',
        category: refs.positionCategory?.value || '',
        farm: refs.positionFarm?.value || '',
        chicken_house: refs.positionHouse?.value || '',
        rooms: Array.from(refs.positionRooms?.selectedOptions || []).map((option) => option.value),
        valid_from: refs.positionValidFrom?.value || '',
        valid_until: refs.positionValidUntil?.value || '',
        handoff_position: refs.positionHandoff?.value || '',
      });

      const openPositionForm = (position = null) => {
        resetForm(refs.positionForm, refs.positionMessage);
        toggleWrapper(refs.positionFormWrapper, true);
        setEditingPosition(position ? position.id : null);
        if (!position) {
          refs.positionId.value = '';
          if (refs.positionCodeDisplay) {
            refs.positionCodeDisplay.classList.add('hidden');
          }
          if (refs.positionCodeValue) {
            refs.positionCodeValue.textContent = '—';
          }
          const currentFarm = refs.positionFarm?.value || '';
          updateHouseOptions(currentFarm, { selectedHouse: '', selectedRooms: [], keepValue: false });
          updateHandoffOptions({ excludeId: null, selected: '', farmId: currentFarm, keepValue: false });
          if (refs.positionHandoff) {
            refs.positionHandoff.value = '';
          }
          if (refs.positionRooms) {
            Array.from(refs.positionRooms.options || []).forEach((option) => {
              option.selected = false;
            });
          }
        } else {
          refs.positionId.value = position.id;
          refs.positionName.value = position.name || '';
          if (refs.positionCodeDisplay) {
            refs.positionCodeDisplay.classList.add('hidden');
          }
          if (refs.positionCodeValue) {
            refs.positionCodeValue.textContent = position.code || '—';
          }
          refs.positionCategory.value = position.category_id || '';
          refs.positionValidFrom.value = position.valid_from || '';
          refs.positionValidUntil.value = position.valid_until || '';
          const farmId = position.farm?.id ? String(position.farm.id) : '';
          const houseId = position.chicken_house?.id ? String(position.chicken_house.id) : '';
          const roomIds = Array.isArray(position.rooms)
            ? position.rooms.map((room) => String(room.id))
            : [];
          refs.positionFarm.value = farmId;
          updateHouseOptions(farmId, { selectedHouse: houseId, selectedRooms: roomIds, keepValue: false });
          const handoffId = position.handoff_position_id ? String(position.handoff_position_id) : '';
          updateHandoffOptions({
            excludeId: position.id,
            selected: handoffId,
            fallbackPosition: position.handoff_position || null,
            keepValue: false,
            farmId: farmId,
          });
          if (refs.positionHandoff) {
            refs.positionHandoff.value = handoffId;
          }
        }
        focusWrapper(refs.positionFormWrapper, refs.positionName);
      };

      const closePositionForm = () => {
        setEditingPosition(null);
        resetForm(refs.positionForm, refs.positionMessage);
        toggleWrapper(refs.positionFormWrapper, false);
        if (refs.positionCodeDisplay) {
          refs.positionCodeDisplay.classList.add('hidden');
        }
        if (refs.positionCodeValue) {
          refs.positionCodeValue.textContent = '—';
        }
        const currentFarm = refs.positionFarm?.value || '';
        updateHandoffOptions({ keepValue: false, farmId: currentFarm, excludeId: null, selected: '' });
        if (refs.positionHandoff) {
          refs.positionHandoff.value = '';
        }
      };

      const getOperatorPayload = () => {
        const employmentStartValue = refs.operatorEmploymentStart?.value || '';
        const employmentEndValue = refs.operatorEmploymentEnd?.value || '';
        const accessKeyValue = refs.operatorAccessKey?.value || '';
        const salaries = getSalaryEntriesFromDom();
        if (!salaries.length) {
          setFormMessage(refs.operatorMessage, 'Debes registrar al menos un salario para el colaborador.', 'error');
          return null;
        }
        for (let index = 0; index < salaries.length; index += 1) {
          const salary = salaries[index];
          const amountValue = Number(salary.amount);
          if (!salary.effective_from) {
            setFormMessage(
              refs.operatorMessage,
              `Define la fecha de inicio para el salario #${index + 1}.`,
              'error'
            );
            return null;
          }
          if (!salary.payment_type) {
            setFormMessage(
              refs.operatorMessage,
              `Selecciona el esquema de pago para el salario #${index + 1}.`,
              'error'
            );
            return null;
          }
          if (!salary.amount || !Number.isFinite(amountValue) || amountValue <= 0) {
            setFormMessage(
              refs.operatorMessage,
              `Ingresa un monto válido para el salario #${index + 1}.`,
              'error'
            );
            return null;
          }
        }

        return {
          cedula: refs.operatorDocument?.value.trim() || '',
          telefono: refs.operatorPhone?.value.trim() || '',
          nombres: refs.operatorFirstName?.value.trim() || '',
          apellidos: refs.operatorLastName?.value.trim() || '',
          employment_start_date: employmentStartValue,
          employment_end_date: employmentEndValue,
          access_key: accessKeyValue.trim(),
          automatic_rest_days: getSelectedRestDays(),
          roles: Array.from(refs.operatorRoles?.selectedOptions || []).map((option) => option.value),
          suggested_positions: Array.from(refs.operatorSuggestedPositions?.selectedOptions || [])
            .map((option) => Number(option.value))
            .filter((value) => Number.isFinite(value)),
          salaries,
        };
      };

      const openOperatorForm = (operator = null) => {
        resetForm(refs.operatorForm, refs.operatorMessage);
        toggleWrapper(refs.operatorFormWrapper, true);
        setEditingOperator(operator ? operator.id : null);
        if (!operator) {
          if (refs.operatorId) {
            refs.operatorId.value = '';
          }
          if (refs.operatorDocument) {
            refs.operatorDocument.value = '';
          }
          if (refs.operatorPhone) {
            refs.operatorPhone.value = '';
          }
          if (refs.operatorFirstName) {
            refs.operatorFirstName.value = '';
          }
          if (refs.operatorLastName) {
            refs.operatorLastName.value = '';
          }
          if (refs.operatorEmploymentStart) {
            refs.operatorEmploymentStart.value = '';
          }
          if (refs.operatorEmploymentEnd) {
            refs.operatorEmploymentEnd.value = '';
          }
          if (refs.operatorAccessKey) {
            refs.operatorAccessKey.value = '';
          }
          if (refs.operatorRoles) {
            Array.from(refs.operatorRoles.options).forEach((option) => {
              option.selected = false;
            });
          }
          if (refs.operatorSuggestedPositions) {
            Array.from(refs.operatorSuggestedPositions.options || []).forEach((option) => {
              option.selected = false;
            });
          }
          setSelectedRestDays([]);
          setOperatorRestContext(null);
        } else {
          if (refs.operatorId) {
            refs.operatorId.value = operator.id ?? '';
          }
          if (refs.operatorDocument) {
            refs.operatorDocument.value = operator.document || '';
          }
          if (refs.operatorPhone) {
            refs.operatorPhone.value = operator.telefono || '';
          }
          if (refs.operatorFirstName) {
            refs.operatorFirstName.value = operator.nombres || '';
          }
          if (refs.operatorLastName) {
            refs.operatorLastName.value = operator.apellidos || '';
          }
          if (refs.operatorEmploymentStart) {
            refs.operatorEmploymentStart.value = operator.employment_start || '';
          }
          if (refs.operatorEmploymentEnd) {
            refs.operatorEmploymentEnd.value = operator.employment_end || '';
          }
          if (refs.operatorAccessKey) {
            refs.operatorAccessKey.value = '';
          }
          if (refs.operatorRoles) {
            const operatorRoles = new Set((operator.roles || []).map((role) => String(role.id)));
            Array.from(refs.operatorRoles.options).forEach((option) => {
              option.selected = operatorRoles.has(option.value);
            });
          }
          if (refs.operatorSuggestedPositions) {
            const suggested = new Set(
              (operator.suggested_positions || []).map((item) => String(item.id ?? item))
            );
            Array.from(refs.operatorSuggestedPositions.options || []).forEach((option) => {
              option.selected = suggested.has(option.value);
            });
          }
          setSelectedRestDays(operator.automatic_rest_days || []);
          setOperatorRestContext(operator.id);
        }
        setSalaryRows(operator?.salaries || []);
        focusWrapper(refs.operatorFormWrapper, refs.operatorDocument);
      };

      const closeOperatorForm = () => {
        setEditingOperator(null);
        resetForm(refs.operatorForm, refs.operatorMessage);
        toggleWrapper(refs.operatorFormWrapper, false);
        if (refs.operatorSuggestedPositions) {
          Array.from(refs.operatorSuggestedPositions.options || []).forEach((option) => {
            option.selected = false;
          });
        }
        if (refs.operatorAccessKey) {
          refs.operatorAccessKey.value = '';
        }
        setSelectedRestDays([]);
        setOperatorRestContext(null);
        clearSalaryRows();
      };

      const submitEntity = async ({ url, method, payload, messageRef, successMessage, onSuccess }) => {
        if (messageRef) {
          setFormMessage(messageRef, 'Guardando…', 'info');
        }
        try {
          const response = await apiRequest(url, { method, body: payload });
          if (!response.ok) {
            let errorMessage = 'No fue posible guardar la información.';
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              if (data?.error) {
                errorMessage = data.error;
              } else if (data?.errors) {
                const firstField = Object.keys(data.errors)[0];
                if (firstField) {
                  errorMessage = data.errors[firstField][0];
                }
              }
            } else {
              const text = await response.text();
              if (text) {
                errorMessage = text;
              }
            }
            if (messageRef) {
              setFormMessage(messageRef, errorMessage, 'error');
            }
            return;
          }

          if (messageRef) {
            setFormMessage(messageRef, successMessage || 'Cambios guardados correctamente.', 'success');
          }
          if (onSuccess) {
            onSuccess();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          if (messageRef) {
            setFormMessage(messageRef, 'Error inesperado. Intenta nuevamente.', 'error');
          }
        }
      };

      const deleteEntity = async (url, { afterSuccess } = {}) => {
        try {
          const response = await apiRequest(url, { method: 'DELETE' });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            let errorMessage = 'No fue posible eliminar el registro.';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              if (data?.error) {
                errorMessage = data.error;
              }
            } else {
              const text = await response.text();
              if (text) {
                errorMessage = text;
              }
            }
            updateMetadataStatus(errorMessage, 'error');
            return;
          }
          if (afterSuccess) {
            afterSuccess();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error eliminando el registro. Intenta nuevamente.', 'error');
        }
      };

      const persistPositionOrder = async (orderedIds, optimisticPositions = null) => {
        if (!Array.isArray(orderedIds) || !orderedIds.length || !API.positionReorder) {
          return;
        }
        if (!state.metadata || state.orderLocked) {
          return;
        }

        if (optimisticPositions) {
          state.metadata.positions = optimisticPositions.map((position, index) => ({
            ...position,
            display_order: index + 1,
          }));
          renderPositions();
        }

        updateMetadataStatus('Guardando nuevo orden de posiciones…', 'info');
        try {
          const response = await apiRequest(API.positionReorder, {
            method: 'POST',
            body: { order: orderedIds },
          });
          if (!response.ok) {
            throw new Error('No fue posible reordenar las posiciones.');
          }
          await fetchMetadata();
          updateMetadataStatus('Orden de posiciones actualizado.', 'success');
        } catch (error) {
          console.error(error);
          updateMetadataStatus('No fue posible reordenar las posiciones.', 'error');
          await fetchMetadata();
        }
      };


      refs.positionFarm?.addEventListener('change', (event) => {
        const farmId = event.target.value || '';
        updateHouseOptions(farmId, { selectedHouse: '', selectedRooms: [], keepValue: false });
        updateHandoffOptions({
          farmId,
          excludeId: state.editing.positionId,
          selected: '',
          keepValue: false,
        });
        if (refs.positionHandoff) {
          refs.positionHandoff.value = '';
        }
      });

      refs.positionHouse?.addEventListener('change', (event) => {
        updateRoomOptions(event.target.value, { selectedRooms: [], keepValue: false });
      });

      const showStep = (requestedStep, { syncUrl = true } = {}) => {
        const step = availableSteps.has(requestedStep) ? requestedStep : (sortedSteps[0] ?? requestedStep);

        refs.sections.forEach((section) => {
          const current = Number(section.getAttribute('data-step-index'));
          if (current === step) {
            section.classList.remove('hidden');
          } else {
            section.classList.add('hidden');
          }
        });

        refs.navButtons.forEach((button) => {
          const target = Number(button.getAttribute('data-step-trigger'));
          if (target === step) {
            button.classList.add('bg-brand', 'text-white');
            button.classList.remove('text-slate-600');
          } else {
            button.classList.remove('bg-brand', 'text-white');
            button.classList.add('text-slate-600');
          }
        });

        if (view === 'configurator' && syncUrl) {
          const url = new URL(window.location.href);
          const slug = stepSlugMap[step];
          if (slug) {
            url.searchParams.set('step', slug);
          } else {
            url.searchParams.delete('step');
          }
          const newUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', newUrl);
        }
      };

      refs.navButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const target = Number(button.getAttribute('data-step-trigger'));
          showStep(target);
        });
      });

      app.querySelectorAll('[data-action="next"]').forEach((button) => {
        button.addEventListener('click', () => {
          const next = Number(button.getAttribute('data-next-step'));
          showStep(next);
        });
      });

      app.querySelectorAll('[data-action="prev"]').forEach((button) => {
        button.addEventListener('click', () => {
          const prev = Number(button.getAttribute('data-prev-step'));
          showStep(prev);
        });
      });

      const renderPositions = () => {
        if (!refs.positionsBody || !state.metadata) {
          return;
        }

        const includeInactive = state.filters.includeInactivePositions;
        const rawPositions = Array.isArray(state.metadata.positions)
          ? [...state.metadata.positions]
          : [];
        const getOrderValue = (item) => {
          const raw = Number(item?.display_order);
          return Number.isFinite(raw) ? raw : 0;
        };

        rawPositions.sort((a, b) => {
          const diff = getOrderValue(a) - getOrderValue(b);
          if (diff !== 0) {
            return diff;
          }
          return (a.id || 0) - (b.id || 0);
        });

        const visiblePositions = includeInactive
          ? rawPositions
          : rawPositions.filter((position) => position.is_active);

        if (!visiblePositions.length) {
          const emptyMessage = includeInactive
            ? 'No hay posiciones registradas en este momento.'
            : 'No hay posiciones activas en este momento.';
          refs.positionsBody.innerHTML = `<tr><td colspan="4" class="px-3 py-4 text-center text-sm text-slate-500">${emptyMessage}</td></tr>`;
          return;
        }

        const allowReorder =
          !state.orderLocked && Boolean(API.positionReorder) && visiblePositions.length > 1;

        if (refs.positionOrderStatus) {
          if (state.orderLocked) {
            refs.positionOrderStatus.classList.remove('hidden');
          } else {
            refs.positionOrderStatus.classList.add('hidden');
          }
        }

        refs.positionsBody.innerHTML = visiblePositions
          .map((position, index) => {
            const orderValue = getOrderValue(position);
            const orderLabel = orderValue > 0 ? orderValue : index + 1;
            const validity = position.valid_until
              ? `${escapeHtml(position.valid_from)} → ${escapeHtml(position.valid_until)}`
              : `${escapeHtml(position.valid_from)} → vigencia abierta`;
            const farmLabel = position.farm?.name ? escapeHtml(position.farm.name) : '';
            const houseLabel = position.chicken_house?.name ? escapeHtml(position.chicken_house.name) : '';
            const roomLabels = (position.rooms || []).map((room) => escapeHtml(room.name)).join(', ');
            const handoffId = position.handoff_position?.id ?? null;
            let handoffLabel = '';
            if (handoffId) {
              const detailed =
                state.lookups.positionsById.get(Number(handoffId)) ||
                position.handoff_position;
              const description =
                describeHandoffPosition(detailed) ||
                formatPositionLabel(detailed) ||
                `Posición ${handoffId}`;
              handoffLabel = escapeHtml(description);
            }
            const isEditing = state.editing.positionId === position.id;
            const rowClassList = ['transition-colors', 'hover:bg-slate-50'];
            if (!position.is_active) {
              rowClassList.push('bg-slate-50', 'text-slate-500');
            }
            if (isEditing) {
              rowClassList.push(
                'bg-amber-50',
                'ring-2',
                'ring-amber-300',
                'ring-offset-1',
                'ring-offset-white'
              );
            }
            const rowAttr = rowClassList.length ? ` class="${rowClassList.join(' ')}"` : '';
            const disableUp = index === 0;
            const disableDown = index === visiblePositions.length - 1;
            const moveButtonBase = 'inline-flex h-7 w-7 items-center justify-center rounded-full bg-slate-200 text-slate-600 shadow-sm transition hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-brand focus:ring-offset-1';
            const disabledClasses = 'cursor-not-allowed opacity-40 hover:bg-slate-200';
            const moveUpClasses = `${moveButtonBase} ${disableUp ? disabledClasses : ''}`;
            const moveDownClasses = `${moveButtonBase} ${disableDown ? disabledClasses : ''}`;
            return `
              <tr${rowAttr} data-position-id="${position.id}">
                <td class="px-3 py-3 align-top">
                  <div class="flex items-start gap-3">
                    <span class="inline-flex items-center justify-center rounded-full bg-slate-200 px-2 text-xs font-semibold text-slate-700">#${orderLabel}</span>
                    <div>
                      <p class="font-semibold text-slate-800">${escapeHtml(position.name)}</p>
                      <p class="text-xs text-slate-500">
                        ${escapeHtml(position.code)}
                        ${farmLabel ? ` · ${farmLabel}` : ''}
                        ${houseLabel ? ` · ${houseLabel}` : ''}
                      </p>
                      ${
                        roomLabels
                          ? `<p class="mt-1 text-xs text-slate-500">Salones: ${roomLabels}</p>`
                          : ''
                      }
                      ${
                        handoffLabel
                          ? `<p class="mt-1 text-xs text-slate-500">Entrega a: ${handoffLabel}</p>`
                          : ''
                      }
                    </div>
                  </div>
                </td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${validity}</td>
                <td class="px-3 py-3 align-top">
                  <span class="inline-flex items-center rounded-full px-2.5 py-1 text-xs font-medium ${
                    position.is_active ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-200 text-slate-600'
                  }">
                    ${position.is_active ? 'Activo' : 'Inactivo'}
                  </span>
                </td>
                <td class="px-3 py-3 align-top">
                  <div class="flex flex-wrap gap-2">
                    ${
                      allowReorder
                        ? `
                      <div class="flex gap-1">
                        <button type="button" data-action="position-move" data-direction="up" data-id="${position.id}" class="${moveUpClasses}" ${
                            disableUp ? 'disabled' : ''
                          } aria-label="Mover arriba" title="Mover arriba">
                          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path d="M10 5.25a.75.75 0 0 1 .53.22l4.25 4.25a.75.75 0 1 1-1.06 1.06L10 7.06 6.28 10.78a.75.75 0 1 1-1.06-1.06l4.25-4.25A.75.75 0 0 1 10 5.25Z"/>
                          </svg>
                          <span class="sr-only">Mover arriba</span>
                        </button>
                        <button type="button" data-action="position-move" data-direction="down" data-id="${position.id}" class="${moveDownClasses}" ${
                            disableDown ? 'disabled' : ''
                          } aria-label="Mover abajo" title="Mover abajo">
                          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path d="M9.47 14.53a.75.75 0 0 0 1.06 0l4.25-4.25a.75.75 0 1 0-1.06-1.06L10 12.44 6.28 9.22a.75.75 0 1 0-1.06 1.06l4.25 4.25Z"/>
                          </svg>
                          <span class="sr-only">Mover abajo</span>
                        </button>
                      </div>
                    `
                        : ''
                    }
                    <button type="button" data-action="position-edit" data-id="${position.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                    <button type="button" data-action="position-delete" data-id="${position.id}" class="rounded border border-red-200 px-2 py-1 text-xs text-red-700 hover:bg-red-50">Eliminar</button>
                  </div>
                </td>
              </tr>
            `;
          })
          .join('');
      };

      const renderOperators = () => {
        if (!state.metadata || !refs.operatorBody) {
          return;
        }

        const searchTerm = (refs.operatorSearch?.value || '').toLowerCase();
        const positionFilter = refs.operatorPositionFilter?.value || '';
        const includeInactiveOperators = state.filters.includeInactiveOperators;

        const operators = Array.isArray(state.metadata.operators)
          ? [...state.metadata.operators]
          : [];

        const filtered = operators.filter((operator) => {
          if (!includeInactiveOperators && !operator.is_active) {
            return false;
          }
          const name = (operator.name || '').toLowerCase();
          const document = (operator.document || '').toLowerCase();
          const matchesSearch = !searchTerm || name.includes(searchTerm) || document.includes(searchTerm);
          if (!matchesSearch) {
            return false;
          }

          if (!positionFilter) {
            return true;
          }

          const suggestions = operator.suggested_positions || [];
          return suggestions.some((item) => String(item.id ?? item) === positionFilter);
        });

        if (refs.operatorCount) {
          refs.operatorCount.textContent = `${filtered.length} colaboradores`;
        }

        if (!filtered.length) {
          refs.operatorBody.innerHTML =
            '<tr><td colspan="4" class="px-3 py-4 text-center text-sm text-slate-500">No encontramos colaboradores con ese criterio.</td></tr>';
          return;
        }

        refs.operatorBody.innerHTML = filtered
          .map((operator) => {
            const suggestionLabels = (operator.suggested_positions || []).map((item) => {
              const positionId = item?.id ?? item;
              const detailed =
                state.lookups.positionsById.get(Number(positionId)) ||
                item;
              const label =
                state.lookups.positionLabels.get(String(positionId)) ||
                formatPositionLabel(detailed) ||
                `Posición ${positionId}`;
              return escapeHtml(label);
            });
            const suggestionsLine = suggestionLabels.length
              ? `<p class="text-xs text-slate-500">Posiciones sugeridas: ${suggestionLabels.join(', ')}</p>`
              : '<p class="text-xs text-slate-500">Sin posiciones sugeridas</p>';

            const restDayLabels = (operator.automatic_rest_days || []).map((value) => {
              const label = state.lookups.dayLabels.get(String(value));
              return escapeHtml(label || value);
            });

            const roles = (operator.roles || []).map((role) => escapeHtml(role.label)).join(', ');
            const rolesLine = roles
              ? `<p class="text-xs text-slate-500">Roles: ${roles}</p>`
              : '';
            const salarySummary = describeSalarySummary(operator.current_salary);
            const salaryLine = `<p class="text-xs text-slate-500">Salario: ${escapeHtml(salarySummary)}</p>`;
            const statusBadge = operator.is_active
              ? '<span class="inline-flex items-center rounded-full bg-emerald-100 px-2.5 py-1 text-xs font-medium text-emerald-700">Activo</span>'
              : '<span class="inline-flex items-center rounded-full bg-slate-200 px-2.5 py-1 text-xs font-medium text-slate-600">Inactivo</span>';
            const isEditing = state.editing.operatorId === operator.id;
            const rowClassList = ['transition-colors'];
            if (isEditing) {
              rowClassList.push(
                'bg-amber-50',
                'ring-2',
                'ring-amber-300',
                'ring-offset-1',
                'ring-offset-white',
                'hover:bg-amber-50'
              );
            } else {
              rowClassList.push('hover:bg-slate-50');
              if (operator.is_active) {
                rowClassList.push('bg-white');
              } else {
                rowClassList.push('bg-slate-50', 'text-slate-500');
              }
            }
            if (isEditing) {
              rowClassList.push('bg-amber-50', 'ring-2', 'ring-amber-300', 'ring-offset-1', 'ring-offset-white');
            }
            const rowClasses = rowClassList.join(' ');
            const contactLine = operator.telefono
              ? `${escapeHtml(operator.document)} · ${escapeHtml(operator.telefono)}`
              : escapeHtml(operator.document);

            return `
              <tr class="${rowClasses}" data-operator-id="${operator.id}">
                <td class="px-3 py-3 align-top">
                  <p class="font-semibold text-slate-800">${escapeHtml(operator.name)}</p>
                  <p class="text-xs text-slate-500">${contactLine}</p>
                  ${rolesLine}
                  ${salaryLine}
                </td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${suggestionsLine}</td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${statusBadge}</td>
                <td class="px-3 py-3 align-top min-w-[12rem]">
                  <div class="flex items-center gap-2 whitespace-nowrap">
                    <button type="button" data-action="operator-edit" data-id="${operator.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                  </div>
                </td>
              </tr>
            `;
          })
          .join('');
      };

      const populateOperatorPositionFilter = () => {
        if (!refs.operatorPositionFilter || !state.metadata) {
          return;
        }

        const select = refs.operatorPositionFilter;
        const currentValue = select.value;
        const suggestedPositionIds = new Set();
        (state.metadata.operators || []).forEach((operator) => {
          (operator.suggested_positions || []).forEach((item) => {
            const rawValue = item?.id ?? item ?? '';
            const value = String(rawValue);
            if (value) {
              suggestedPositionIds.add(value);
            }
          });
        });

        const sortedValues = Array.from(suggestedPositionIds).sort((a, b) => {
          const labelA = state.lookups.positionLabels.get(a) || `Posición ${a}`;
          const labelB = state.lookups.positionLabels.get(b) || `Posición ${b}`;
          return labelA.localeCompare(labelB, 'es');
        });

        select.innerHTML =
          '<option value="">Todas las posiciones</option>' +
          sortedValues
            .map((value) => {
              const label = state.lookups.positionLabels.get(value) || `Posición ${value}`;
              return `<option value="${escapeHtml(value)}">${escapeHtml(label)}</option>`;
            })
            .join('');

        if (currentValue && suggestedPositionIds.has(currentValue)) {
          select.value = currentValue;
        } else {
          select.value = '';
        }
      };

      const renderSummary = (summary) => {
        if (!refs.summaryPreview) {
          return;
        }

        if (!summary) {
          refs.summaryPreview.innerHTML = '<p class="text-slate-500">El resumen aparecerá después de generar el calendario.</p>';
          refs.calendarActions.hidden = true;
          refs.reloadSummaryBtn.classList.add('hidden');
          return;
        }

        const stats = summary.stats || {};
        const rows = summary.rows || [];
        const firstRows = rows.slice(0, 5).map((row) => {
          const position = row.position;
          const firstAssignment = (row.cells || []).find((cell) => cell.assignment);
          const operatorName = firstAssignment?.assignment?.operator?.name || 'Sin cobertura';
          const alertLabel = firstAssignment?.assignment?.alert_level || 'none';
          return `
            <tr>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(position.name)}</td>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(operatorName)}</td>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(alertLabel)}</td>
            </tr>
          `;
        }).join('');

        refs.summaryPreview.innerHTML = `
          <div class="grid gap-3 text-sm text-slate-600">
            <div class="grid grid-cols-2 gap-3">
              <div class="rounded border border-emerald-200 bg-emerald-50 px-3 py-2">
                <p class="text-xs text-emerald-800">Asignaciones</p>
                <p class="text-lg font-semibold text-emerald-800">${stats.total_assignments ?? 0}</p>
              </div>
              <div class="rounded border border-amber-200 bg-amber-50 px-3 py-2">
                <p class="text-xs text-amber-800">Alertas</p>
                <p class="text-lg font-semibold text-amber-800">${(stats.warn ?? 0) + (stats.critical ?? 0)}</p>
              </div>
            </div>
            <div class="rounded border border-slate-200">
              <table class="min-w-full divide-y divide-slate-200 text-xs">
                <thead class="bg-slate-100 font-semibold text-slate-600">
                  <tr>
                    <th class="px-3 py-2 text-left">Posición</th>
                    <th class="px-3 py-2 text-left">Operario inicial</th>
                    <th class="px-3 py-2 text-left">Alerta</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-slate-100">${firstRows || '<tr><td colspan="3" class="px-3 py-2 text-center text-slate-500">Sin asignaciones registradas.</td></tr>'}</tbody>
              </table>
            </div>
          </div>
        `;

        refs.calendarActions.hidden = false;
        refs.reloadSummaryBtn.classList.remove('hidden');
      };

      const fetchSummary = () => {
        if (!state.calendarId) {
          renderSummary(null);
          return;
        }

        apiRequest(replaceId(API.summaryTemplate, state.calendarId))
          .then((response) => {
            if (!response.ok) {
              throw new Error('No fue posible obtener el resumen.');
            }
            return response.json();
          })
          .then((data) => {
            state.lastSummary = data;
            renderSummary(data);
          })
          .catch((error) => {
            console.error(error);
            refs.summaryPreview.innerHTML = '<p class="text-sm text-red-600">No se pudo actualizar el resumen, intenta más tarde.</p>';
          });
      };

      const setFeedback = (message, tone = 'info') => {
        if (!refs.calendarFeedback) {
          return;
        }

        refs.calendarFeedback.classList.remove('hidden');
        refs.calendarFeedback.className = 'rounded border px-4 py-3 text-sm';

        if (tone === 'error') {
          refs.calendarFeedback.classList.add('border-red-200', 'bg-red-50', 'text-red-700');
        } else if (tone === 'success') {
          refs.calendarFeedback.classList.add('border-emerald-200', 'bg-emerald-50', 'text-emerald-800');
        } else {
          refs.calendarFeedback.classList.add('border-slate-200', 'bg-slate-50', 'text-slate-600');
        }

        refs.calendarFeedback.textContent = message;
      };

      const generateCalendar = () => {
        const nameInput = document.getElementById('calendar-name');
        const startInput = document.getElementById('calendar-start');
        const endInput = document.getElementById('calendar-end');
        const notesInput = document.getElementById('calendar-notes');

        if (!startInput?.value || !endInput?.value) {
          setFeedback('Debes ingresar fecha de inicio y fin antes de generar.', 'error');
          return;
        }

        const payload = {
          name: nameInput?.value || '',
          start_date: startInput.value,
          end_date: endInput.value,
          notes: notesInput?.value || '',
        };

        setFeedback('Generando calendario, por favor espera…');

        apiRequest(API.generate, { method: 'POST', body: payload })
          .then((response) => {
            if (!response.ok) {
              return response.text().then((text) => {
                throw new Error(text || 'No fue posible generar el calendario.');
              });
            }
            return response.json();
          })
          .then((data) => {
            state.calendarId = data.calendar_id;
            state.orderLocked = true;
            renderPositions();
            updateMetadataStatus('El orden de las posiciones ha sido bloqueado para este borrador.', 'info');
            setFeedback('Calendario generado con éxito. Revisa el resumen y ajusta las asignaciones antes de aprobar.', 'success');
            if (refs.calendarDetailLink && API.calendarDetailTemplate) {
              refs.calendarDetailLink.href = replaceId(API.calendarDetailTemplate, state.calendarId);
            }
            fetchSummary();
          })
          .catch((error) => {
            console.error(error);
            setFeedback(error.message || 'Ocurrió un error durante la generación.', 'error');
          });
      };

      refs.operatorForm?.addEventListener('submit', (event) => {
        event.preventDefault();
        const payload = getOperatorPayload();
        if (!payload) {
          return;
        }
        const id = refs.operatorId?.value;
        submitEntity({
          url: id ? replaceId(API.operatorDetailTemplate, id) : API.operators,
          method: id ? 'PATCH' : 'POST',
          payload,
          messageRef: refs.operatorMessage,
          successMessage: id ? 'Colaborador actualizado correctamente.' : 'Colaborador registrado correctamente.',
          onSuccess: () => {
            closeOperatorForm();
          },
        });
      });

      
      refs.positionForm?.addEventListener('submit', (event) => {
        event.preventDefault();
        const payload = getPositionPayload();
        const id = refs.positionId?.value;
        submitEntity({
          url: id ? replaceId(API.positionDetailTemplate, id) : API.positions,
          method: id ? 'PATCH' : 'POST',
          payload,
          messageRef: refs.positionMessage,
          successMessage: id ? 'Posición actualizada correctamente.' : 'Posición creada correctamente.',
          onSuccess: () => {
            closePositionForm();
          },
        });
      });

      refs.operatorAddBtn?.addEventListener('click', () => openOperatorForm());
      refs.operatorCancelBtn?.addEventListener('click', () => closeOperatorForm());
      refs.operatorRefreshBtn?.addEventListener('click', () => fetchMetadata());
      refs.positionAddBtn?.addEventListener('click', () => openPositionForm());
      refs.positionCancelBtn?.addEventListener('click', () => closePositionForm());
      refs.operatorSalaryAddBtn?.addEventListener('click', () => addSalaryRow({}, { atStart: true }));
      refs.operatorSalaryList?.addEventListener('click', (event) => {
        const button = event.target.closest('[data-action="salary-remove"]');
        if (!button) {
          return;
        }
        const row = button.closest('[data-salary-row]');
        if (!row) {
          return;
        }
        row.remove();
        updateSalaryEmptyHint();
      });
      refs.operatorCapabilityAddBtn?.addEventListener('click', () => addOperatorCapabilityRow());
      refs.operatorRestAddBtn?.addEventListener('click', () => openRestForm());
      refs.operatorRestCancelBtn?.addEventListener('click', () => closeRestForm());
      refs.operatorRestFilters?.addEventListener('click', (event) => {
        const button = event.target.closest('.rest-filter-btn');
        if (!button) {
          return;
        }
        const key = button.dataset.filter;
        if (!key) {
          return;
        }
        state.restFilters[key] = !state.restFilters[key];
        if (!state.restFilters.past && !state.restFilters.current && !state.restFilters.future) {
          state.restFilters[key] = true;
        }
        syncRestFiltersUI();
        renderOperatorRestList(state.editing.restOperatorId);
      });
      refs.operatorRestSaveBtn?.addEventListener('click', () => {
        const payload = buildRestPayload();
        if (!payload.operator) {
          setFormMessage(refs.operatorRestMessage, 'Debes seleccionar un colaborador válido.', 'error');
          return;
        }
        if (!Number.isFinite(payload.operator)) {
          setFormMessage(refs.operatorRestMessage, 'El identificador del colaborador no es válido.', 'error');
          return;
        }
        if (!payload.start_date || !payload.end_date) {
          setFormMessage(refs.operatorRestMessage, 'Debes ingresar fechas de inicio y fin.', 'error');
          return;
        }
        const restIdRaw = refs.operatorRestId?.value || '';
        const restId = restIdRaw ? Number.parseInt(restIdRaw, 10) : null;
        const rangeLabel = `${formatDateLabel(payload.start_date)} → ${formatDateLabel(payload.end_date)}`;
        if (!confirmRestAction(`¿Confirmas guardar el descanso ${rangeLabel}?`)) {
          return;
        }
        persistRestPeriod(payload, {
          id: restId,
          successMessage: restId ? 'Descanso actualizado correctamente.' : 'Descanso registrado correctamente.',
        });
      });
      refs.positionsRefreshBtn?.addEventListener('click', () => fetchMetadata());
      refs.positionIncludeInactive?.addEventListener('change', (event) => {
        state.filters.includeInactivePositions = Boolean(event.target?.checked);
        fetchMetadata();
      });
      refs.operatorIncludeInactive?.addEventListener('change', (event) => {
        state.filters.includeInactiveOperators = Boolean(event.target?.checked);
        renderOperators();
      });
      refs.reloadSummaryBtn?.addEventListener('click', () => fetchSummary());
      refs.generateCalendarBtn?.addEventListener('click', () => generateCalendar());
      syncRestFiltersUI();

      const handlePositionMove = (id, direction) => {
        if (!state.metadata) {
          return;
        }
        if (state.orderLocked) {
          updateMetadataStatus('No es posible reordenar las posiciones después de generar el calendario.', 'warning');
          return;
        }
        const delta = direction === 'up' ? -1 : direction === 'down' ? 1 : 0;
        if (!delta) {
          return;
        }

        const positions = Array.isArray(state.metadata.positions)
          ? [...state.metadata.positions]
          : [];
        if (positions.length < 2) {
          return;
        }

        const currentIndex = positions.findIndex((position) => position.id === id);
        if (currentIndex < 0) {
          return;
        }
        const targetIndex = currentIndex + delta;
        if (targetIndex < 0 || targetIndex >= positions.length) {
          return;
        }

        const swapped = [...positions];
        [swapped[currentIndex], swapped[targetIndex]] = [swapped[targetIndex], swapped[currentIndex]];
        const orderedIds = swapped.map((position) => position.id);
        persistPositionOrder(orderedIds, swapped);
      };

      const handleOperatorEdit = (id) => {
        const operator = state.metadata?.operators?.find((item) => item.id === id);
        if (!operator) {
          updateMetadataStatus('No encontramos datos para el colaborador seleccionado.', 'warning');
          return;
        }
        openOperatorForm(operator);
      };

      const handlePositionEdit = (id) => {
        const position = state.metadata?.positions?.find((item) => item.id === id);
        if (!position) {
          return;
        }
        openPositionForm(position);
      };

      const performPositionDelete = (id) => {
        deleteEntity(replaceId(API.positionDetailTemplate, id), {
          afterSuccess: () => {
            if (refs.positionId?.value === String(id)) {
              closePositionForm();
            }
          },
        });
      };

      const handlePositionDelete = (id) => {
        if (!Number.isFinite(id) || id <= 0) {
          return;
        }
        if (openPositionDeleteDialog(id)) {
          return;
        }
        if (!confirm('¿Confirma eliminar esta posición? Esta acción no se puede deshacer.')) {
          return;
        }
        performPositionDelete(id);
      };

      if (refs.positionDeleteCancel) {
        refs.positionDeleteCancel.addEventListener('click', () => {
          closePositionDeleteDialog();
        });
      }

      if (refs.positionDeleteDialog) {
        refs.positionDeleteDialog.addEventListener('click', (event) => {
          if (event.target === refs.positionDeleteDialog) {
            closePositionDeleteDialog();
          }
        });
        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && !refs.positionDeleteDialog.classList.contains('hidden')) {
            closePositionDeleteDialog();
          }
        });
      }

      if (refs.positionDeleteConfirm) {
        refs.positionDeleteConfirm.addEventListener('click', () => {
          const id = pendingPositionDeleteId;
          closePositionDeleteDialog();
          if (Number.isFinite(id) && id > 0) {
            performPositionDelete(id);
          }
        });
      }

      app.addEventListener('click', (event) => {
        const target = event.target.closest('[data-action]');
        if (!target) {
          return;
        }
        const action = target.dataset.action;
        const idRaw = target.dataset.id;
        const id = idRaw !== undefined ? Number.parseInt(idRaw, 10) : NaN;
        switch (action) {
          case 'operator-edit':
            handleOperatorEdit(id);
            break;
          case 'position-move':
            handlePositionMove(id, target.dataset.direction);
            break;
          case 'position-edit':
            handlePositionEdit(id);
            break;
          case 'position-delete':
            handlePositionDelete(id);
            break;
          case 'rest-edit': {
            if (!Number.isFinite(id) || id <= 0) {
              return;
            }
            const period = getRestPeriodById(id);
            if (!period) {
              updateMetadataStatus('No encontramos el descanso seleccionado.', 'warning');
              return;
            }
            openRestForm(period);
            break;
          }
          case 'rest-delete': {
            if (!Number.isFinite(id) || id <= 0) {
              return;
            }
            const period = getRestPeriodById(id);
            if (!period) {
              updateMetadataStatus('No encontramos el descanso seleccionado.', 'warning');
              return;
            }
            const label = formatRestRange(period);
            if (!confirmRestAction(`¿Eliminar el descanso ${label}?`)) {
              return;
            }
            deleteRestPeriod(period);
            break;
          }
          default:
            break;
        }
      });

      const fetchMetadata = async () => {
        updateMetadataStatus('Cargando información…', 'info');
        try {
          const params = new URLSearchParams();
          if (state.filters.includeInactivePositions) {
            params.set('include_inactive', 'true');
          }
          const url = params.toString() ? `${API.metadata}?${params.toString()}` : API.metadata;
          const response = await apiRequest(url);
          if (!response.ok) {
            throw new Error('No fue posible obtener los datos.');
          }
          const data = await response.json();
          state.metadata = data;
          if (Array.isArray(state.metadata?.positions)) {
            state.metadata.positions.sort((a, b) => {
              const orderA = Number(a?.display_order);
              const orderB = Number(b?.display_order);
              const safeA = Number.isFinite(orderA) ? orderA : 0;
              const safeB = Number.isFinite(orderB) ? orderB : 0;
              if (safeA !== safeB) {
                return safeA - safeB;
              }
              return (a.id || 0) - (b.id || 0);
            });
          }
          if (refs.positionIncludeInactive) {
            refs.positionIncludeInactive.checked = state.filters.includeInactivePositions;
          }
          if (refs.operatorIncludeInactive) {
            refs.operatorIncludeInactive.checked = state.filters.includeInactiveOperators;
          }
          renderRestDayOptions();
          rebuildLookups();
          populateStaticOptions();
          renderPositions();
          populateOperatorPositionFilter();
          renderOperators();
          renderOperatorRestList(state.editing.restOperatorId);
          syncRestFiltersUI();
          updateMetadataStatus('Información actualizada.', 'success');
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error cargando datos. Intenta nuevamente o revisa tu conexión.', 'error');
        }
      };

      const initFilters = () => {
        refs.operatorSearch?.addEventListener('input', () => renderOperators());
        refs.operatorPositionFilter?.addEventListener('change', () => renderOperators());
      };

      const resolveInitialStep = () => {
        if (!sortedSteps.length) {
          return { step: 1, source: null };
        }
        const url = new URL(window.location.href);
        const hashValue = (url.hash || '').replace('#', '').trim();
        let source = null;
        let raw = (url.searchParams.get('step') || '').trim();
        if (raw) {
          source = 'search';
        } else if (hashValue) {
          source = 'hash';
          raw = hashValue.toLowerCase().startsWith('step=') ? hashValue.slice(5) : hashValue;
        }
        const candidate = raw.toLowerCase();
        if (candidate && slugToStep.has(candidate)) {
          const mapped = slugToStep.get(candidate);
          if (availableSteps.has(mapped)) {
            return { step: mapped, source };
          }
        }
        const numericCandidate = Number(candidate);
        if (candidate && !Number.isNaN(numericCandidate) && availableSteps.has(numericCandidate)) {
          return { step: numericCandidate, source };
        }
        return { step: sortedSteps[0], source: null };
      };

      initFilters();
      updateSalaryEmptyHint();
      fetchMetadata();
      const { step: initialStep, source: initialSource } = resolveInitialStep();
      const syncInitialStep = initialSource !== null;
      showStep(initialStep, { syncUrl: syncInitialStep });
      refs.generateCalendarBtn?.addEventListener('click', () => generateCalendar());
      refs.reloadSummaryBtn?.addEventListener('click', () => fetchSummary());
    })();
  </script>
