<script>
    (() => {
      const app = document.getElementById('configurator-app');
      if (!app) {
        return;
      }
      const view = app.dataset.view || 'configurator';

      const API = {
        metadata: app.dataset.metadataUrl,
        generate: app.dataset.generateUrl,
        summaryTemplate: app.dataset.summaryUrlTemplate,
        assignmentsTemplate: app.dataset.assignmentsUrlTemplate,
        eligibleTemplate: app.dataset.eligibleUrlTemplate,
        calendarDetailTemplate: app.dataset.calendarDetailUrlTemplate,
        dashboard: app.dataset.dashboardUrl,
        positions: app.dataset.positionsUrl,
        positionDetailTemplate: app.dataset.positionDetailUrlTemplate,
        positionReorder: app.dataset.positionReorderUrl,
        capabilities: app.dataset.capabilitiesUrl,
        capabilityDetailTemplate: app.dataset.capabilityDetailUrlTemplate,
        operators: app.dataset.operatorsUrl,
        operatorDetailTemplate: app.dataset.operatorDetailUrlTemplate,
        restPeriods: app.dataset.restPeriodsUrl,
        restPeriodDetailTemplate: app.dataset.restPeriodDetailUrlTemplate,
      };

      const state = {
        metadata: null,
        calendarId: null,
        lastSummary: null,
        orderLocked: false,
        filters: {
          includeInactivePositions: false,
          includeInactiveOperators: false,
        },
        restFilters: {
          past: false,
          current: true,
          future: true,
          last15: false,
          next15: false,
        },
        editing: {
          positionId: null,
          operatorId: null,
          operatorCapabilities: [],
          restOperatorId: null,
          restPeriodId: null,
        },
        lookups: {
          housesByFarm: new Map(),
          roomsByHouse: new Map(),
          operatorsById: new Map(),
          farmsById: new Map(),
          rolesById: new Map(),
          categoriesById: new Map(),
          categoryLabels: new Map(),
          complexityLabels: new Map(),
          skillLabels: new Map(),
          shiftLabels: new Map(),
          alertLabels: new Map(),
          dayLabels: new Map(),
          restStatusLabels: new Map(),
          restSourceLabels: new Map(),
        },
      };

      const refreshPositionHighlight = () => {
        if (state.metadata && refs.positionsBody) {
          renderPositions();
        }
      };

      const refreshOperatorHighlight = () => {
        if (state.metadata && refs.operatorBody) {
          renderOperators();
        }
      };

      const setEditingPosition = (id) => {
        if (state.editing.positionId === id) {
          return;
        }
        state.editing.positionId = id;
        refreshPositionHighlight();
      };

      const setEditingOperator = (id) => {
        if (state.editing.operatorId === id) {
          return;
        }
        state.editing.operatorId = id;
        refreshOperatorHighlight();
      };

      const refs = {
        sections: Array.from(app.querySelectorAll('[data-step-index]')),
        navButtons: Array.from(app.querySelectorAll('[data-step-trigger]')),
        metadataStatus: app.querySelector('#metadata-status'),
        positionsBody: app.querySelector('#positions-body'),
        positionAddBtn: app.querySelector('#position-add-btn'),
        positionsRefreshBtn: app.querySelector('#refresh-metadata-btn'),
        positionIncludeInactive: app.querySelector('#position-include-inactive'),
        positionOrderStatus: app.querySelector('#position-order-status'),
        positionFormWrapper: app.querySelector('#position-form-wrapper'),
        positionForm: app.querySelector('#position-form'),
        positionMessage: app.querySelector('#position-form-message'),
        positionId: app.querySelector('#position-id'),
        positionName: app.querySelector('#position-name'),
        positionCodeDisplay: app.querySelector('#position-code-display'),
        positionCodeValue: app.querySelector('#position-code-value'),
        positionCategory: app.querySelector('#position-category'),
        positionFarm: app.querySelector('#position-farm'),
        positionHouse: app.querySelector('#position-house'),
        positionRooms: app.querySelector('#position-rooms'),
        positionComplexity: app.querySelector('#position-complexity'),
        positionValidFrom: app.querySelector('#position-valid-from'),
        positionValidUntil: app.querySelector('#position-valid-until'),
        positionAllowLower: app.querySelector('#position-allow-lower'),
        positionIsActive: app.querySelector('#position-is-active'),
        positionNotes: app.querySelector('#position-notes'),
        positionCancelBtn: app.querySelector('#position-cancel-btn'),
        operatorCount: app.querySelector('#operator-count'),
        capabilityCount: app.querySelector('#capability-count'),
        operatorBody: app.querySelector('#operator-body'),
        operatorSearch: app.querySelector('#operator-search'),
        operatorCategoryFilter: app.querySelector('#operator-category-filter'),
        operatorIncludeInactive: app.querySelector('#operator-include-inactive'),
        operatorAddBtn: app.querySelector('#operator-add-btn'),
        operatorRefreshBtn: app.querySelector('#operator-refresh-btn'),
        operatorFormWrapper: app.querySelector('#operator-form-wrapper'),
        operatorForm: app.querySelector('#operator-form'),
        operatorMessage: app.querySelector('#operator-form-message'),
        operatorId: app.querySelector('#operator-id'),
        operatorDocument: app.querySelector('#operator-document'),
        operatorFirstName: app.querySelector('#operator-first-name'),
        operatorLastName: app.querySelector('#operator-last-name'),
        operatorPhone: app.querySelector('#operator-phone'),
        operatorEmail: app.querySelector('#operator-email'),
        operatorEmploymentStart: app.querySelector('#operator-employment-start'),
        operatorEmploymentEnd: app.querySelector('#operator-employment-end'),
        operatorPreferredFarm: app.querySelector('#operator-preferred-farm'),
        operatorRoles: app.querySelector('#operator-roles'),
        operatorIsActive: app.querySelector('#operator-is-active'),
        operatorCancelBtn: app.querySelector('#operator-cancel-btn'),
        operatorCapabilityAddBtn: app.querySelector('#operator-capability-add-btn'),
        operatorCapabilitiesEditor: app.querySelector('#operator-capabilities-editor'),
        operatorRestAddBtn: app.querySelector('#operator-rest-add-btn'),
        operatorRestFilters: app.querySelector('#operator-rest-filters'),
        operatorRestList: app.querySelector('#operator-rest-list'),
        operatorRestEmptyHint: app.querySelector('#operator-rest-empty-hint'),
        operatorRestMessage: app.querySelector('#operator-rest-message'),
        operatorRestFormWrapper: app.querySelector('#operator-rest-form-wrapper'),
        operatorRestForm: app.querySelector('#operator-rest-form'),
        operatorRestId: app.querySelector('#operator-rest-id'),
        operatorRestOperator: app.querySelector('#operator-rest-operator'),
        operatorRestCalendar: app.querySelector('#operator-rest-calendar'),
        operatorRestStart: app.querySelector('#operator-rest-start'),
        operatorRestEnd: app.querySelector('#operator-rest-end'),
        operatorRestStatus: app.querySelector('#operator-rest-status'),
        operatorRestSource: app.querySelector('#operator-rest-source'),
        operatorRestNotes: app.querySelector('#operator-rest-notes'),
        operatorRestCalendarInfo: app.querySelector('#operator-rest-calendar-info'),
        operatorRestEditHint: app.querySelector('#operator-rest-edit-hint'),
        operatorRestCancelBtn: app.querySelector('#operator-rest-cancel-btn'),
        operatorRestSaveBtn: app.querySelector('#operator-rest-save-btn'),
        summaryPreview: app.querySelector('#summary-preview'),
        calendarFeedback: app.querySelector('#calendar-feedback'),
        reloadSummaryBtn: app.querySelector('#reload-summary-btn'),
        calendarActions: app.querySelector('#calendar-actions'),
        calendarDetailLink: app.querySelector('#open-calendar-detail'),
        generateCalendarBtn: document.getElementById('generate-calendar-btn'),
      };

      const availableSteps = new Set(
        refs.sections
          .map((section) => Number(section.getAttribute('data-step-index')))
          .filter((value) => !Number.isNaN(value))
      );
      const sortedSteps = Array.from(availableSteps).sort((a, b) => a - b);
      const stepSlugMap = view === 'configurator'
        ? { 1: 'positions', 2: 'collaborators', 3: 'rules', 4: 'draft' }
        : {};
      const slugToStep = new Map(
        Object.entries(stepSlugMap).map(([step, slug]) => [slug, Number(step)])
      );
      if (view === 'configurator') {
        slugToStep.set('position', 1);
        slugToStep.set('posiciones', 1);
        slugToStep.set('collaboradores', 2);
        slugToStep.set('rules', 3);
        slugToStep.set('reglas', 3);
        slugToStep.set('borrador', 4);
      }
      if (refs.positionIncludeInactive) {
        state.filters.includeInactivePositions = refs.positionIncludeInactive.checked;
      }
      if (refs.operatorIncludeInactive) {
        state.filters.includeInactiveOperators = refs.operatorIncludeInactive.checked;
      }

      const toneClassSets = {
        info: ['border-slate-200', 'bg-slate-50', 'text-slate-600'],
        success: ['border-emerald-200', 'bg-emerald-50', 'text-emerald-700'],
        error: ['border-red-200', 'bg-red-50', 'text-red-700'],
        warning: ['border-amber-200', 'bg-amber-50', 'text-amber-700'],
      };
      const allToneClasses = Object.values(toneClassSets).flat();

      const escapeHtml = (value) => {
        if (value === null || value === undefined) {
          return '';
        }
        return String(value)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };

      const formatDateLabel = (isoDate) => {
        if (!isoDate) {
          return '';
        }
        const parts = String(isoDate).split('-');
        if (parts.length !== 3) {
          return isoDate;
        }
        const [year, month, day] = parts;
        if (!year || !month || !day) {
          return isoDate;
        }
        return `${day.padStart(2, '0')}/${month.padStart(2, '0')}/${year}`;
      };

      let capabilityRowCounter = 0;
      const nextCapabilityRowId = () => {
        capabilityRowCounter += 1;
        return `cap-${capabilityRowCounter}`;
      };

      const allCapabilityChoices = () => state.metadata?.choice_sets?.position_categories || [];

      const activeCapabilityEntries = () => state.editing.operatorCapabilities || [];

      const updateAddCapabilityState = () => {
        if (!refs.operatorCapabilityAddBtn) {
          return;
        }
        const choices = allCapabilityChoices();
        const usedCount = activeCapabilityEntries().length;
        const disable = !choices.length || usedCount >= choices.length;
        refs.operatorCapabilityAddBtn.disabled = disable;
      };

      const renderOperatorCapabilitiesEditor = () => {
        if (!refs.operatorCapabilitiesEditor) {
          return;
        }

        const choices = allCapabilityChoices();
        const entries = activeCapabilityEntries();

        if (!entries.length) {
          refs.operatorCapabilitiesEditor.innerHTML =
            '<p class="rounded border border-slate-200 bg-slate-50 px-4 py-3 text-slate-500">No hay fortalezas registradas.</p>';
          updateAddCapabilityState();
          return;
        }

        const usedCategories = new Set(entries.map((entry) => String(entry.category || '')).filter(Boolean));

        refs.operatorCapabilitiesEditor.innerHTML = entries
          .map((entry) => {
            const options = choices
              .map((choice) => {
                const choiceValue = String(choice.value);
                const entryValue = String(entry.category || '');
                const selected = choiceValue === entryValue ? 'selected' : '';
                const disabled = !selected && usedCategories.has(choiceValue) ? 'disabled' : '';
                return `<option value="${escapeHtml(choice.value)}" ${selected} ${disabled}>${escapeHtml(choice.label)}</option>`;
              })
              .join('');

            const skillScore = Number(entry.skill_score) || 1;
            const skillLabel = state.lookups.skillLabels.get(String(skillScore)) || `${skillScore}/10`;

            return `
              <div class="grid items-start gap-4 md:grid-cols-[minmax(0,1fr)_minmax(220px,1fr)_auto]" data-entry-id="${escapeHtml(entry.id)}">
                <label class="flex flex-col text-sm text-slate-700">
                  Categoría
                  <select data-role="capability-category" data-entry-id="${escapeHtml(entry.id)}" class="mt-1 rounded border border-slate-300 px-3 py-2 focus:border-brand focus:outline-none focus:ring-1 focus:ring-brand">
                    <option value="">Selecciona categoría</option>
                    ${options}
                  </select>
                </label>

                <div class="flex flex-col gap-2">
                  <label class="flex flex-col text-sm text-slate-700">
                    Nivel de habilidad
                    <input type="range" min="1" max="10" value="${skillScore}" data-role="capability-skill" data-entry-id="${escapeHtml(entry.id)}" class="mt-1 w-full accent-emerald-600" />
                  </label>
                  <span class="text-xs font-semibold text-emerald-700" data-role="capability-skill-label" data-entry-id="${escapeHtml(entry.id)}">${escapeHtml(skillLabel)}</span>
                </div>

                <button type="button" class="mt-2 inline-flex items-center rounded border border-red-200 px-3 py-1 text-xs font-medium text-red-700 hover:bg-red-50 md:mt-6" data-action="remove-capability" data-entry-id="${escapeHtml(entry.id)}">Quitar</button>
              </div>
            `;
          })
          .join('');

        refs.operatorCapabilitiesEditor
          .querySelectorAll('[data-role="capability-category"]')
          .forEach((select) => {
            select.addEventListener('change', (event) => {
              const { entryId } = event.target.dataset;
              updateOperatorCapabilityCategory(entryId, event.target.value);
            });
          });

        refs.operatorCapabilitiesEditor
          .querySelectorAll('[data-role="capability-skill"]')
          .forEach((input) => {
            input.addEventListener('input', (event) => {
              const { entryId } = event.target.dataset;
              updateOperatorCapabilitySkill(entryId, Number(event.target.value));
            });
          });

        refs.operatorCapabilitiesEditor
          .querySelectorAll('[data-action="remove-capability"]')
          .forEach((button) => {
            button.addEventListener('click', (event) => {
              const { entryId } = event.target.dataset;
              removeOperatorCapabilityRow(entryId);
            });
          });

        updateAddCapabilityState();
      };

      const setOperatorCapabilitiesDraft = (entries) => {
        state.editing.operatorCapabilities = entries.map((entry) => ({
          id: nextCapabilityRowId(),
          category: String(entry.category_id ?? entry.category?.id ?? ''),
          skill_score: Number(entry.skill_score) || 5,
        }));
        renderOperatorCapabilitiesEditor();
      };

      const resetOperatorCapabilitiesDraft = () => {
        state.editing.operatorCapabilities = [];
        renderOperatorCapabilitiesEditor();
      };

      const addOperatorCapabilityRow = () => {
        const choices = allCapabilityChoices();
        if (!choices.length) {
          return;
        }

        const used = new Set(activeCapabilityEntries().map((entry) => String(entry.category || '')).filter(Boolean));
        const nextChoice = choices.find((choice) => !used.has(choice.value));
        if (!nextChoice) {
          return;
        }

        state.editing.operatorCapabilities = [
          ...activeCapabilityEntries(),
          {
            id: nextCapabilityRowId(),
            category: nextChoice.value,
            skill_score: 5,
          },
        ];
        renderOperatorCapabilitiesEditor();
      };

      const updateOperatorCapabilityCategory = (entryId, value) => {
        if (!entryId) {
          return;
        }
        state.editing.operatorCapabilities = activeCapabilityEntries().map((entry) =>
          entry.id === entryId
            ? {
                ...entry,
                category: value || '',
              }
            : entry,
        );
        renderOperatorCapabilitiesEditor();
      };

      const updateOperatorCapabilitySkill = (entryId, value) => {
        if (!entryId) {
          return;
        }
        const entries = activeCapabilityEntries();
        const entry = entries.find((item) => item.id === entryId);
        if (!entry) {
          return;
        }
        entry.skill_score = value;
        const label = state.lookups.skillLabels.get(String(value)) || `${value}/10`;
        const labelNode = refs.operatorCapabilitiesEditor?.querySelector(
          `[data-role="capability-skill-label"][data-entry-id="${entryId}"]`,
        );
        if (labelNode) {
          labelNode.textContent = label;
        }
      };

      const removeOperatorCapabilityRow = (entryId) => {
        if (!entryId) {
          return;
        }
        state.editing.operatorCapabilities = activeCapabilityEntries().filter((entry) => entry.id !== entryId);
        renderOperatorCapabilitiesEditor();
      };

      const restFilterActiveClasses = ['border-amber-400', 'bg-amber-50', 'text-amber-700', 'hover:bg-amber-100'];
      const restFilterInactiveClasses = ['border-slate-300', 'text-slate-600', 'hover:bg-slate-100'];
      const MS_PER_DAY = 24 * 60 * 60 * 1000;

      const syncRestFiltersUI = () => {
        if (!refs.operatorRestFilters) {
          return;
        }
        refs.operatorRestFilters.querySelectorAll('.rest-filter-btn').forEach((button) => {
          const key = button.dataset.filter;
          if (!key) {
            return;
          }
          const active = Boolean(state.restFilters[key]);
          button.dataset.active = active ? 'true' : 'false';
          button.classList.remove(...restFilterActiveClasses, ...restFilterInactiveClasses);
          if (active) {
            button.classList.add(...restFilterActiveClasses);
          } else {
            button.classList.add(...restFilterInactiveClasses);
          }
        });
      };

      const normalizeIsoDate = (isoDate) => {
        if (!isoDate) {
          return null;
        }
        const parts = String(isoDate).split('-').map((value) => Number.parseInt(value, 10));
        if (parts.length !== 3 || parts.some((value) => Number.isNaN(value))) {
          return null;
        }
        const [year, month, day] = parts;
        return new Date(year, month - 1, day);
      };

      const getToday = () => {
        const now = new Date();
        return new Date(now.getFullYear(), now.getMonth(), now.getDate());
      };

      const classifyRestPeriod = (period) => {
        const startDate = normalizeIsoDate(period.start);
        const endDate = normalizeIsoDate(period.end);
        const today = getToday();
        if (!startDate || !endDate) {
          return {
            isPast: false,
            isCurrent: false,
            isFuture: false,
            pastWithin15: false,
            futureWithin15: false,
          };
        }
        const isPast = endDate < today;
        const isFuture = startDate > today;
        const isCurrent = !isPast && !isFuture;
        const pastWithin15 = isPast && Math.floor((today.getTime() - endDate.getTime()) / MS_PER_DAY) <= 15;
        const futureWithin15 = isFuture && Math.floor((startDate.getTime() - today.getTime()) / MS_PER_DAY) <= 15;
        return {
          isPast,
          isCurrent,
          isFuture,
          pastWithin15,
          futureWithin15,
        };
      };

      const matchesRestFilters = (period) => {
        const filters = state.restFilters;
        const classification = classifyRestPeriod(period);
        const typeFiltersActive = filters.past || filters.current || filters.future;
        const typeMatch =
          (filters.past && classification.isPast) ||
          (filters.current && classification.isCurrent) ||
          (filters.future && classification.isFuture);
        if (typeFiltersActive && !typeMatch) {
          return false;
        }
        if (filters.last15 && !classification.pastWithin15) {
          return false;
        }
        if (filters.next15 && !classification.futureWithin15) {
          return false;
        }
        return true;
      };

      const getRestPeriodsForOperator = (operatorId) => {
        if (!state.metadata || !operatorId) {
          return [];
        }
        return (state.metadata.rest_periods || []).filter((period) => period.operator_id === operatorId);
      };

      const getRestPeriodById = (restId) => {
        if (!state.metadata || !restId) {
          return null;
        }
        return (state.metadata.rest_periods || []).find((period) => period.id === restId) || null;
      };

      const formatRestRange = (period) => {
        const startLabel = formatDateLabel(period.start);
        const endLabel = formatDateLabel(period.end);
        if (startLabel === endLabel) {
          return startLabel;
        }
        return `${startLabel} → ${endLabel}`;
      };

      const formatDateTimeLabel = (isoDateTime) => {
        if (!isoDateTime) {
          return '';
        }
        const [datePart] = String(isoDateTime).split('T');
        return formatDateLabel(datePart);
      };

      const describeRestClassification = (period) => {
        const classification = classifyRestPeriod(period);
        if (classification.isCurrent) {
          return 'En curso';
        }
        if (classification.isFuture) {
          return 'Próximo';
        }
        if (classification.isPast) {
          return 'Histórico';
        }
        return '';
      };

      const sortRestPeriods = (periods) =>
        [...periods].sort((a, b) => {
          const aStart = normalizeIsoDate(a.start);
          const bStart = normalizeIsoDate(b.start);
          if (aStart && bStart && aStart.getTime() !== bStart.getTime()) {
            return bStart.getTime() - aStart.getTime();
          }
          const aEnd = normalizeIsoDate(a.end);
          const bEnd = normalizeIsoDate(b.end);
          if (aEnd && bEnd && aEnd.getTime() !== bEnd.getTime()) {
            return bEnd.getTime() - aEnd.getTime();
          }
          return (b.id || 0) - (a.id || 0);
        });

      const getDefaultRestStatus = () => {
        const statuses = state.metadata?.choice_sets?.rest_statuses || [];
        const planned = statuses.find((choice) => choice.value === 'planned');
        return planned?.value || (statuses[0]?.value || '');
      };

      const getDefaultRestSource = () => {
        const sources = state.metadata?.choice_sets?.rest_sources || [];
        const manual = sources.find((choice) => choice.value === 'manual');
        return manual?.value || (sources[0]?.value || '');
      };

      const renderOperatorRestList = (operatorId) => {
        if (!refs.operatorRestList) {
          return;
        }
        if (!operatorId) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-slate-200 bg-slate-50 px-4 py-3 text-slate-500">Selecciona un colaborador guardado para revisar sus descansos.</p>';
          return;
        }
        const periods = getRestPeriodsForOperator(operatorId);
        if (!periods.length) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-slate-200 bg-slate-50 px-4 py-3 text-slate-500">No hay descansos registrados para este colaborador.</p>';
          return;
        }
        const filtered = periods.filter(matchesRestFilters);
        if (!filtered.length) {
          refs.operatorRestList.innerHTML =
            '<p class="rounded border border-amber-200 bg-amber-50 px-4 py-3 text-amber-700">No hay descansos que coincidan con los filtros seleccionados.</p>';
          return;
        }

        const badgeBase = 'inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-semibold';

        refs.operatorRestList.innerHTML = sortRestPeriods(filtered)
          .map((period) => {
            const statusLabel =
              state.lookups.restStatusLabels.get(period.status) || period.status_label || period.status || '';
            const sourceLabel =
              state.lookups.restSourceLabels.get(period.source) || period.source_label || period.source || '';
            const classificationLabel = describeRestClassification(period);
            const durationDays = Number.parseInt(period.duration_days, 10);
            const durationLabel =
              Number.isFinite(durationDays) && durationDays > 0
                ? `${durationDays} día${durationDays === 1 ? '' : 's'}`
                : '';
            const isSystem = Boolean(period.is_system_generated);
            const containerClasses = [
              'rounded',
              'border',
              'px-4',
              'py-3',
              'text-sm',
              'bg-white',
              'shadow-sm',
              'space-y-2',
            ];
            if (isSystem) {
              containerClasses.push('border-amber-300', 'bg-amber-50/70');
            } else {
              containerClasses.push('border-slate-200');
            }
            const statusBadge = statusLabel
              ? `<span class="${badgeBase} bg-emerald-100 text-emerald-700">${escapeHtml(statusLabel)}</span>`
              : '';
            const sourceBadge = sourceLabel
              ? `<span class="${badgeBase} ${
                  isSystem ? 'bg-amber-200 text-amber-800' : 'bg-slate-200 text-slate-600'
                }">${escapeHtml(sourceLabel)}</span>`
              : '';
            const classificationBadge = classificationLabel
              ? `<span class="${badgeBase} bg-indigo-100 text-indigo-700">${escapeHtml(classificationLabel)}</span>`
              : '';
            const durationBadge = durationLabel
              ? `<span class="${badgeBase} bg-slate-100 text-slate-600">${escapeHtml(durationLabel)}</span>`
              : '';
            const notesLine = period.notes
              ? `<p class="text-xs text-slate-600">Notas: ${escapeHtml(period.notes)}</p>`
              : '';
            const calendarLine = period.calendar
              ? `<p class="text-xs text-slate-600">Calendario origen: <span class="font-medium text-slate-700">${escapeHtml(
                  period.calendar.name || `#${period.calendar.id}`,
                )}</span> (${formatDateLabel(period.calendar.start_date)} → ${formatDateLabel(
                  period.calendar.end_date,
                )})</p>`
              : '';
            const createdLine = period.created_by
              ? `<p class="text-[11px] text-slate-400">Registrado por ${escapeHtml(
                  period.created_by.name || '',
                )} el ${escapeHtml(formatDateTimeLabel(period.created_at) || '')}</p>`
              : '';

            return `
              <div class="${containerClasses.join(' ')}" data-rest-id="${period.id}">
                <div class="flex flex-wrap items-start justify-between gap-3">
                  <div>
                    <p class="font-semibold text-slate-800">${escapeHtml(formatRestRange(period))}</p>
                    <div class="mt-1 flex flex-wrap gap-2">
                      ${statusBadge}
                      ${sourceBadge}
                      ${classificationBadge}
                      ${durationBadge}
                    </div>
                    ${notesLine}
                    ${calendarLine}
                    ${createdLine}
                  </div>
                  <div class="flex flex-wrap gap-2">
                    <button type="button" data-action="rest-edit" data-id="${period.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                    <button type="button" data-action="rest-delete" data-id="${period.id}" class="rounded border border-red-200 px-2 py-1 text-xs text-red-700 hover:bg-red-50">Eliminar</button>
                  </div>
                </div>
              </div>
            `;
          })
          .join('');
      };

      const setOperatorRestContext = (operatorId) => {
        state.editing.restOperatorId = operatorId || null;
        state.editing.restPeriodId = null;
        if (refs.operatorRestAddBtn) {
          const hasOperator = Boolean(operatorId);
          refs.operatorRestAddBtn.disabled = !hasOperator;
          refs.operatorRestAddBtn.classList.toggle('opacity-50', !hasOperator);
          refs.operatorRestAddBtn.classList.toggle('cursor-not-allowed', !hasOperator);
        }
        if (refs.operatorRestEmptyHint) {
          refs.operatorRestEmptyHint.classList.toggle('hidden', Boolean(operatorId));
        }
        toggleWrapper(refs.operatorRestFormWrapper, false);
        setFormMessage(refs.operatorRestMessage, '');
        renderOperatorRestList(operatorId);
      };

      const closeRestForm = () => {
        resetForm(refs.operatorRestForm, refs.operatorRestMessage);
        state.editing.restPeriodId = null;
        if (refs.operatorRestId) {
          refs.operatorRestId.value = '';
        }
        if (refs.operatorRestCalendarInfo) {
          refs.operatorRestCalendarInfo.classList.add('hidden');
          refs.operatorRestCalendarInfo.textContent = '';
        }
        if (refs.operatorRestEditHint) {
          refs.operatorRestEditHint.textContent = '';
        }
        toggleWrapper(refs.operatorRestFormWrapper, false);
      };

      const populateRestForm = (period = null) => {
        if (!refs.operatorRestForm) {
          return;
        }
        setFormMessage(refs.operatorRestMessage, '');
        if (refs.operatorRestId) {
          refs.operatorRestId.value = period?.id ? String(period.id) : '';
        }
        if (refs.operatorRestOperator) {
          const operatorId = period?.operator_id || state.editing.restOperatorId;
          refs.operatorRestOperator.value = operatorId ? String(operatorId) : '';
        }
        if (refs.operatorRestCalendar) {
          refs.operatorRestCalendar.value = period?.calendar_id ? String(period.calendar_id) : '';
        }
        if (refs.operatorRestStart) {
          refs.operatorRestStart.value = period?.start || '';
        }
        if (refs.operatorRestEnd) {
          refs.operatorRestEnd.value = period?.end || '';
        }
        if (refs.operatorRestStatus) {
          refs.operatorRestStatus.value = period?.status || getDefaultRestStatus() || '';
        }
        if (refs.operatorRestSource) {
          refs.operatorRestSource.value = period?.source || getDefaultRestSource() || '';
        }
        if (refs.operatorRestNotes) {
          refs.operatorRestNotes.value = period?.notes || '';
        }
        if (refs.operatorRestCalendarInfo) {
          if (period?.calendar) {
            const calendarText = `Calendario origen: ${period.calendar.name || `#${period.calendar.id}`} (${formatDateLabel(
              period.calendar.start_date,
            )} → ${formatDateLabel(period.calendar.end_date)})`;
            refs.operatorRestCalendarInfo.textContent = calendarText;
            refs.operatorRestCalendarInfo.classList.remove('hidden');
          } else {
            refs.operatorRestCalendarInfo.textContent = '';
            refs.operatorRestCalendarInfo.classList.add('hidden');
          }
        }
        if (refs.operatorRestEditHint) {
          const hintParts = [
            'Los descansos impactan la planificación de turnos.',
            'Confirma la operación dos veces antes de guardar.',
          ];
          if (period?.is_system_generated) {
            hintParts.push('Este descanso proviene de un calendario generado automáticamente.');
          }
          refs.operatorRestEditHint.textContent = hintParts.join(' ');
        }
      };

      const openRestForm = (period = null) => {
        const operatorId = period?.operator_id || state.editing.restOperatorId;
        if (!operatorId) {
          updateMetadataStatus('Primero debes guardar al colaborador para gestionar descansos.', 'warning');
          return;
        }
        state.editing.restPeriodId = period?.id || null;
        populateRestForm(period);
        toggleWrapper(refs.operatorRestFormWrapper, true);
        focusWrapper(refs.operatorRestFormWrapper, refs.operatorRestStart);
      };

      const buildRestPayload = () => {
        const operatorValue = refs.operatorRestOperator?.value || '';
        const payload = {
          operator: operatorValue ? Number(operatorValue) : null,
          start_date: refs.operatorRestStart?.value || '',
          end_date: refs.operatorRestEnd?.value || '',
          status: refs.operatorRestStatus?.value || '',
          source: refs.operatorRestSource?.value || '',
          notes: refs.operatorRestNotes?.value?.trim() || '',
        };
        const calendarValue = refs.operatorRestCalendar?.value || '';
        if (calendarValue) {
          payload.calendar = Number(calendarValue);
        } else {
          payload.calendar = null;
        }
        return payload;
      };

      const confirmRestAction = (message) => {
        const firstMessage =
          message ||
          'Vas a modificar un descanso. Esta acción puede impactar las asignaciones existentes y las reglas configuradas.';
        const first = window.confirm(`${firstMessage}\n\n¿Deseas continuar?`);
        if (!first) {
          return false;
        }
        const second = window.confirm('Confirma nuevamente para aplicar el cambio en los descansos.');
        return second;
      };

      const persistRestPeriod = async (payload, { id = null, successMessage } = {}) => {
        if (!API.restPeriods) {
          return;
        }
        const url = id && API.restPeriodDetailTemplate ? replaceId(API.restPeriodDetailTemplate, id) : API.restPeriods;
        const method = id ? 'PATCH' : 'POST';
        setFormMessage(refs.operatorRestMessage, 'Guardando descanso…', 'info');
        try {
          const response = await apiRequest(url, { method, body: payload });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              const errorMessage = data?.error || 'No fue posible guardar el descanso.';
              setFormMessage(refs.operatorRestMessage, errorMessage, 'error');
            } else {
              const text = await response.text();
              setFormMessage(refs.operatorRestMessage, text || 'No fue posible guardar el descanso.', 'error');
            }
            return;
          }
          const data = await response.json();
          setFormMessage(refs.operatorRestMessage, successMessage || 'Descanso guardado correctamente.', 'success');
          if (data?.requires_calendar_refresh) {
            updateMetadataStatus(
              'Los cambios en descansos pueden requerir actualizar o recrear el calendario.',
              'warning',
            );
          } else {
            updateMetadataStatus('Información actualizada.', 'success');
          }
          closeRestForm();
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          setFormMessage(refs.operatorRestMessage, 'Error al guardar el descanso. Intenta nuevamente.', 'error');
        }
      };

      const deleteRestPeriod = async (period) => {
        if (!API.restPeriodDetailTemplate) {
          return;
        }
        const url = replaceId(API.restPeriodDetailTemplate, period.id);
        try {
          const response = await apiRequest(url, { method: 'DELETE' });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              updateMetadataStatus(data?.error || 'No fue posible eliminar el descanso.', 'error');
            } else {
              const text = await response.text();
              updateMetadataStatus(text || 'No fue posible eliminar el descanso.', 'error');
            }
            return;
          }
          const data = await response.json();
          if (data?.requires_calendar_refresh) {
            updateMetadataStatus(
              'Se eliminó el descanso. Recuerda actualizar o recrear el calendario para reflejar los cambios.',
              'warning',
            );
          } else {
            updateMetadataStatus('Descanso eliminado correctamente.', 'success');
          }
          if (state.editing.restPeriodId === period.id) {
            closeRestForm();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error eliminando el descanso. Intenta nuevamente.', 'error');
        }
      };

      const replaceId = (template, id) => template.replace('/0/', `/${id}/`);

      const setFormMessage = (element, message = '', tone = 'info') => {
        if (!element) {
          return;
        }
        if (!message) {
          element.classList.add('hidden');
          element.textContent = '';
          return;
        }
        element.classList.remove('hidden');
        element.classList.remove(...allToneClasses);
        const classes = toneClassSets[tone] || toneClassSets.info;
        element.classList.add(...classes);
        element.textContent = message;
      };

      const updateMetadataStatus = (message, tone = 'info') => {
        setFormMessage(refs.metadataStatus, message, tone);
      };

      const toggleWrapper = (wrapper, visible) => {
        if (!wrapper) {
          return;
        }
        wrapper.classList.toggle('hidden', !visible);
      };

      const focusableSelector =
        'input:not([type="hidden"]):not([disabled]):not([readonly]), select:not([disabled]), textarea:not([disabled])';

      const focusWrapper = (wrapper, preferred = null) => {
        if (!wrapper) {
          return;
        }
        requestAnimationFrame(() => {
          wrapper.scrollIntoView({ behavior: 'smooth', block: 'start', inline: 'nearest' });
          const target = preferred || wrapper.querySelector(focusableSelector);
          if (target && typeof target.focus === 'function') {
            try {
              target.focus({ preventScroll: true });
            } catch (error) {
              target.focus();
            }
          }
        });
      };

      const resetForm = (form, messageEl) => {
        if (form) {
          if (typeof form.reset === 'function') {
            form.reset();
          } else {
            form.querySelectorAll('input, select, textarea').forEach((field) => {
              const tag = field.tagName.toLowerCase();
              if (tag === 'input') {
                const input = field;
                if (input.type === 'checkbox' || input.type === 'radio') {
                  input.checked = false;
                } else {
                  input.value = '';
                }
              } else if (tag === 'select') {
                const select = field;
                if ('options' in select && 'selectedIndex' in select) {
                  select.selectedIndex = select.options.length ? 0 : -1;
                }
              } else if (tag === 'textarea') {
                const textarea = field;
                textarea.value = '';
              }
            });
          }
        }
        if (messageEl) {
          setFormMessage(messageEl, '');
        }
      };

      const csrfSafeMethods = new Set(['GET', 'HEAD', 'OPTIONS', 'TRACE']);

      const getCookie = (name) => {
        if (typeof document === 'undefined') {
          return '';
        }
        const cookies = document.cookie ? document.cookie.split('; ') : [];
        for (const cookie of cookies) {
          if (cookie.startsWith(`${name}=`)) {
            return decodeURIComponent(cookie.slice(name.length + 1));
          }
        }
        return '';
      };

      const getCsrfToken = () => getCookie('csrftoken');

      const apiRequest = (url, { method = 'GET', body } = {}) => {
        const upperMethod = (method || 'GET').toUpperCase();
        const headers = { 'X-Requested-With': 'XMLHttpRequest' };
        if (!csrfSafeMethods.has(upperMethod)) {
          const token = getCsrfToken();
          if (token) {
            headers['X-CSRFToken'] = token;
          }
        }
        const options = {
          method: upperMethod,
          headers,
        };
        options.credentials = 'same-origin';
        if (body !== undefined) {
          options.body = JSON.stringify(body);
          options.headers['Content-Type'] = 'application/json';
        }
        return fetch(url, options);
      };

      const populateSelect = (
        select,
        items,
        {
          valueKey = 'value',
          labelKey = 'label',
          includeBlank = true,
          blankLabel = 'Seleccione…',
          keepValue = true,
          selectedValues = null,
        } = {}
      ) => {
        if (!select) {
          return;
        }
        const isMultiple = Boolean(select.multiple);
        const previousValues = keepValue
          ? Array.from(select.selectedOptions || []).map((option) => option.value)
          : [];
        select.innerHTML = '';
        if (includeBlank && !isMultiple) {
          const option = document.createElement('option');
          option.value = '';
          option.textContent = blankLabel;
          select.append(option);
        }
        const selectedSet = new Set(
          (selectedValues ?? (keepValue ? previousValues : [])).map((value) => String(value))
        );
        (items || []).forEach((item) => {
          const value = String(item[valueKey]);
          const option = document.createElement('option');
          option.value = value;
          option.textContent = item[labelKey];
          if (selectedSet.has(value)) {
            option.selected = true;
          }
          select.append(option);
        });
        if (!isMultiple) {
          const targetValue =
            selectedValues && selectedValues.length
              ? String(selectedValues[0])
              : keepValue && previousValues.length
              ? String(previousValues[0])
              : '';
          if (targetValue) {
            select.value = targetValue;
          } else if (!includeBlank && select.options.length) {
            select.selectedIndex = 0;
          }
        }
      };

      const rebuildLookups = () => {
        if (!state.metadata || state.orderLocked) {
          return;
        }

        const housesByFarm = new Map();
        state.metadata.chicken_houses.forEach((house) => {
          const list = housesByFarm.get(house.farm_id) || [];
          list.push(house);
          housesByFarm.set(house.farm_id, list);
        });
        housesByFarm.forEach((list) => list.sort((a, b) => a.name.localeCompare(b.name)));

        const roomsByHouse = new Map();
        state.metadata.rooms.forEach((room) => {
          const list = roomsByHouse.get(room.chicken_house_id) || [];
          list.push(room);
          roomsByHouse.set(room.chicken_house_id, list);
        });
        roomsByHouse.forEach((list) => list.sort((a, b) => a.name.localeCompare(b.name)));

        const operatorsById = new Map();
        state.metadata.operators.forEach((operator) => {
          operatorsById.set(operator.id, operator);
        });

        const farmsById = new Map();
        state.metadata.farms.forEach((farm) => {
          farmsById.set(farm.id, farm);
        });

        const rolesById = new Map();
        state.metadata.roles.forEach((role) => {
          rolesById.set(role.id, role);
        });

        const categoriesById = new Map();
        (state.metadata.categories || []).forEach((category) => {
          categoriesById.set(String(category.id), category);
        });

        const choiceMap = (choices) => {
          const map = new Map();
          choices.forEach((choice) => {
            map.set(choice.value, choice.label);
          });
          return map;
        };

        state.lookups = {
          housesByFarm,
          roomsByHouse,
          operatorsById,
          farmsById,
          rolesById,
          categoriesById,
          categoryLabels: choiceMap(state.metadata.choice_sets.position_categories),
          complexityLabels: choiceMap(state.metadata.choice_sets.complexity_levels),
          skillLabels: choiceMap(state.metadata.choice_sets.skill_levels),
          shiftLabels: choiceMap(state.metadata.choice_sets.shift_types),
          alertLabels: choiceMap(state.metadata.choice_sets.alert_levels),
          dayLabels: choiceMap(state.metadata.choice_sets.days_of_week),
          restStatusLabels: choiceMap(state.metadata.choice_sets.rest_statuses || []),
          restSourceLabels: choiceMap(state.metadata.choice_sets.rest_sources || []),
        };
      };

      const updateRoomOptions = (houseId, { selectedRooms = [], keepValue = true } = {}) => {
        if (!refs.positionRooms) {
          return;
        }
        if (!houseId) {
          populateSelect(refs.positionRooms, [], { includeBlank: false, keepValue: false, selectedValues: [] });
          return;
        }
        const rooms = state.lookups.roomsByHouse.get(Number(houseId)) || [];
        populateSelect(refs.positionRooms, rooms, {
          valueKey: 'id',
          labelKey: 'name',
          includeBlank: false,
          keepValue,
          selectedValues: selectedRooms,
        });
      };

      const updateHouseOptions = (farmId, { selectedHouse = '', selectedRooms = [], keepValue = true } = {}) => {
        if (!refs.positionHouse) {
          return;
        }
        const houses = state.lookups.housesByFarm.get(Number(farmId)) || [];
        const selectedValues = selectedHouse ? [selectedHouse] : keepValue ? [refs.positionHouse.value] : [];
        populateSelect(refs.positionHouse, houses, {
          valueKey: 'id',
          labelKey: 'name',
          includeBlank: true,
          blankLabel: 'Todos los galpones',
          keepValue: false,
          selectedValues,
        });
        const currentHouse = selectedValues[0] || '';
        if (selectedHouse) {
          refs.positionHouse.value = selectedHouse;
        } else if (!keepValue) {
          refs.positionHouse.value = '';
        } else {
          refs.positionHouse.value = currentHouse;
        }
        const effectiveHouse = refs.positionHouse.value || '';
        updateRoomOptions(effectiveHouse, { selectedRooms, keepValue: false });
      };

      const findCategory = (categoryId) => {
        const target = String(categoryId || '');
        return state.lookups.categoriesById.get(target) || null;
      };

      const populateStaticOptions = () => {
        if (!state.metadata || state.orderLocked) {
          return;
        }

        populateSelect(refs.positionCategory, state.metadata.choice_sets.position_categories, { blankLabel: 'Selecciona categoría' });
        populateSelect(refs.positionFarm, state.metadata.farms, { valueKey: 'id', labelKey: 'name', blankLabel: 'Selecciona granja' });
        populateSelect(refs.positionComplexity, state.metadata.choice_sets.complexity_levels, { blankLabel: 'Selecciona nivel de criticidad' });

        populateSelect(refs.operatorRoles, state.metadata.roles, { valueKey: 'id', labelKey: 'label', includeBlank: false, keepValue: false });
        populateSelect(refs.operatorPreferredFarm, state.metadata.farms, {
          valueKey: 'id',
          labelKey: 'name',
          blankLabel: '(sin preferencia)',
          keepValue: true,
        });
        populateSelect(refs.operatorRestStatus, state.metadata.choice_sets.rest_statuses || [], {
          blankLabel: 'Selecciona estado',
          keepValue: true,
        });
        populateSelect(refs.operatorRestSource, state.metadata.choice_sets.rest_sources || [], {
          blankLabel: 'Selecciona origen',
          keepValue: true,
        });

        updateHouseOptions(refs.positionFarm?.value || '');
      };

      const getPositionPayload = () => ({
        name: refs.positionName?.value.trim() || '',
        category: refs.positionCategory?.value || '',
        farm: refs.positionFarm?.value || '',
        chicken_house: refs.positionHouse?.value || '',
        rooms: Array.from(refs.positionRooms?.selectedOptions || []).map((option) => option.value),
        complexity: refs.positionComplexity?.value || '',
        allow_lower_complexity: Boolean(refs.positionAllowLower?.checked),
        valid_from: refs.positionValidFrom?.value || '',
        valid_until: refs.positionValidUntil?.value || '',
        is_active: Boolean(refs.positionIsActive?.checked),
        notes: refs.positionNotes?.value.trim() || '',
      });

      const openPositionForm = (position = null) => {
        resetForm(refs.positionForm, refs.positionMessage);
        toggleWrapper(refs.positionFormWrapper, true);
        setEditingPosition(position ? position.id : null);
        if (!position) {
          refs.positionId.value = '';
          refs.positionIsActive.checked = true;
          refs.positionAllowLower.checked = false;
          if (refs.positionCodeDisplay) {
            refs.positionCodeDisplay.classList.add('hidden');
          }
          if (refs.positionCodeValue) {
            refs.positionCodeValue.textContent = '—';
          }
          const currentFarm = refs.positionFarm?.value || '';
          updateHouseOptions(currentFarm, { selectedHouse: '', selectedRooms: [], keepValue: false });
          if (refs.positionRooms) {
            Array.from(refs.positionRooms.options || []).forEach((option) => {
              option.selected = false;
            });
          }
        } else {
          refs.positionId.value = position.id;
          refs.positionName.value = position.name || '';
          if (refs.positionCodeDisplay) {
            refs.positionCodeDisplay.classList.add('hidden');
          }
          if (refs.positionCodeValue) {
            refs.positionCodeValue.textContent = position.code || '—';
          }
          refs.positionCategory.value = position.category_id || '';
          refs.positionComplexity.value = position.complexity || '';
          refs.positionValidFrom.value = position.valid_from || '';
          refs.positionValidUntil.value = position.valid_until || '';
          refs.positionAllowLower.checked = Boolean(position.allow_lower_complexity);
          refs.positionIsActive.checked = Boolean(position.is_active);
          refs.positionNotes.value = position.notes || '';
          const farmId = position.farm?.id ? String(position.farm.id) : '';
          const houseId = position.chicken_house?.id ? String(position.chicken_house.id) : '';
          const roomIds = Array.isArray(position.rooms)
            ? position.rooms.map((room) => String(room.id))
            : [];
          refs.positionFarm.value = farmId;
          updateHouseOptions(farmId, { selectedHouse: houseId, selectedRooms: roomIds, keepValue: false });
        }
        focusWrapper(refs.positionFormWrapper, refs.positionName);
      };

      const closePositionForm = () => {
        setEditingPosition(null);
        resetForm(refs.positionForm, refs.positionMessage);
        toggleWrapper(refs.positionFormWrapper, false);
        if (refs.positionCodeDisplay) {
          refs.positionCodeDisplay.classList.add('hidden');
        }
        if (refs.positionCodeValue) {
          refs.positionCodeValue.textContent = '—';
        }
      };

      const getOperatorPayload = () => {
        const preferredFarmValue = refs.operatorPreferredFarm?.value || '';
        const employmentStartValue = refs.operatorEmploymentStart?.value || '';
        const employmentEndValue = refs.operatorEmploymentEnd?.value || '';
        return {
          cedula: refs.operatorDocument?.value.trim() || '',
          telefono: refs.operatorPhone?.value.trim() || '',
          nombres: refs.operatorFirstName?.value.trim() || '',
          apellidos: refs.operatorLastName?.value.trim() || '',
          email: refs.operatorEmail?.value.trim() || '',
          employment_start_date: employmentStartValue,
          employment_end_date: employmentEndValue,
          preferred_farm: preferredFarmValue ? Number(preferredFarmValue) : null,
          roles: Array.from(refs.operatorRoles?.selectedOptions || []).map((option) => option.value),
          is_active: Boolean(refs.operatorIsActive?.checked),
          capabilities: activeCapabilityEntries()
            .filter((entry) => entry.category)
            .map((entry) => ({
              category: String(entry.category),
              skill_score: Number(entry.skill_score) || 1,
            })),
        };
      };

      const openOperatorForm = (operator = null) => {
        resetForm(refs.operatorForm, refs.operatorMessage);
        toggleWrapper(refs.operatorFormWrapper, true);
        setEditingOperator(operator ? operator.id : null);
        if (!operator) {
          if (refs.operatorId) {
            refs.operatorId.value = '';
          }
          if (refs.operatorDocument) {
            refs.operatorDocument.value = '';
          }
          if (refs.operatorPhone) {
            refs.operatorPhone.value = '';
          }
          if (refs.operatorFirstName) {
            refs.operatorFirstName.value = '';
          }
          if (refs.operatorLastName) {
            refs.operatorLastName.value = '';
          }
          if (refs.operatorEmail) {
            refs.operatorEmail.value = '';
          }
          if (refs.operatorEmploymentStart) {
            refs.operatorEmploymentStart.value = '';
          }
          if (refs.operatorEmploymentEnd) {
            refs.operatorEmploymentEnd.value = '';
          }
          if (refs.operatorPreferredFarm) {
            refs.operatorPreferredFarm.value = '';
          }
          if (refs.operatorRoles) {
            Array.from(refs.operatorRoles.options).forEach((option) => {
              option.selected = false;
            });
          }
          if (refs.operatorIsActive) {
            refs.operatorIsActive.checked = true;
          }
          resetOperatorCapabilitiesDraft();
          setOperatorRestContext(null);
        } else {
          if (refs.operatorId) {
            refs.operatorId.value = operator.id ?? '';
          }
          if (refs.operatorDocument) {
            refs.operatorDocument.value = operator.document || '';
          }
          if (refs.operatorPhone) {
            refs.operatorPhone.value = operator.telefono || '';
          }
          if (refs.operatorFirstName) {
            refs.operatorFirstName.value = operator.nombres || '';
          }
          if (refs.operatorLastName) {
            refs.operatorLastName.value = operator.apellidos || '';
          }
          if (refs.operatorEmail) {
            refs.operatorEmail.value = operator.email || '';
          }
          if (refs.operatorEmploymentStart) {
            refs.operatorEmploymentStart.value = operator.employment_start || '';
          }
          if (refs.operatorEmploymentEnd) {
            refs.operatorEmploymentEnd.value = operator.employment_end || '';
          }
          if (refs.operatorPreferredFarm) {
            refs.operatorPreferredFarm.value = operator.preferred_farm?.id
              ? String(operator.preferred_farm.id)
              : '';
          }
          if (refs.operatorRoles) {
            const operatorRoles = new Set((operator.roles || []).map((role) => String(role.id)));
            Array.from(refs.operatorRoles.options).forEach((option) => {
              option.selected = operatorRoles.has(option.value);
            });
          }
          if (refs.operatorIsActive) {
            refs.operatorIsActive.checked = Boolean(operator.is_active);
          }
          const operatorCapabilities = (state.metadata?.capabilities || []).filter(
            (capability) => capability.operator_id === operator.id,
          );
          setOperatorCapabilitiesDraft(operatorCapabilities);
          setOperatorRestContext(operator.id);
        }
        updateAddCapabilityState();
        focusWrapper(refs.operatorFormWrapper, refs.operatorDocument);
      };

      const closeOperatorForm = () => {
        setEditingOperator(null);
        resetForm(refs.operatorForm, refs.operatorMessage);
        toggleWrapper(refs.operatorFormWrapper, false);
        resetOperatorCapabilitiesDraft();
        setOperatorRestContext(null);
      };

      const submitEntity = async ({ url, method, payload, messageRef, successMessage, onSuccess }) => {
        if (messageRef) {
          setFormMessage(messageRef, 'Guardando…', 'info');
        }
        try {
          const response = await apiRequest(url, { method, body: payload });
          if (!response.ok) {
            let errorMessage = 'No fue posible guardar la información.';
            const contentType = response.headers.get('content-type') || '';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              if (data?.error) {
                errorMessage = data.error;
              } else if (data?.errors) {
                const firstField = Object.keys(data.errors)[0];
                if (firstField) {
                  errorMessage = data.errors[firstField][0];
                }
              }
            } else {
              const text = await response.text();
              if (text) {
                errorMessage = text;
              }
            }
            if (messageRef) {
              setFormMessage(messageRef, errorMessage, 'error');
            }
            return;
          }

          if (messageRef) {
            setFormMessage(messageRef, successMessage || 'Cambios guardados correctamente.', 'success');
          }
          if (onSuccess) {
            onSuccess();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          if (messageRef) {
            setFormMessage(messageRef, 'Error inesperado. Intenta nuevamente.', 'error');
          }
        }
      };

      const deleteEntity = async (url, { afterSuccess } = {}) => {
        try {
          const response = await apiRequest(url, { method: 'DELETE' });
          if (!response.ok) {
            const contentType = response.headers.get('content-type') || '';
            let errorMessage = 'No fue posible eliminar el registro.';
            if (contentType.includes('application/json')) {
              const data = await response.json();
              if (data?.error) {
                errorMessage = data.error;
              }
            } else {
              const text = await response.text();
              if (text) {
                errorMessage = text;
              }
            }
            updateMetadataStatus(errorMessage, 'error');
            return;
          }
          if (afterSuccess) {
            afterSuccess();
          }
          await fetchMetadata();
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error eliminando el registro. Intenta nuevamente.', 'error');
        }
      };

      const persistPositionOrder = async (orderedIds, optimisticPositions = null) => {
        if (!Array.isArray(orderedIds) || !orderedIds.length || !API.positionReorder) {
          return;
        }
        if (!state.metadata || state.orderLocked) {
          return;
        }

        if (optimisticPositions) {
          state.metadata.positions = optimisticPositions.map((position, index) => ({
            ...position,
            display_order: index + 1,
          }));
          renderPositions();
        }

        updateMetadataStatus('Guardando nuevo orden de posiciones…', 'info');
        try {
          const response = await apiRequest(API.positionReorder, {
            method: 'POST',
            body: { order: orderedIds },
          });
          if (!response.ok) {
            throw new Error('No fue posible reordenar las posiciones.');
          }
          await fetchMetadata();
          updateMetadataStatus('Orden de posiciones actualizado.', 'success');
        } catch (error) {
          console.error(error);
          updateMetadataStatus('No fue posible reordenar las posiciones.', 'error');
          await fetchMetadata();
        }
      };


      refs.positionFarm?.addEventListener('change', (event) => {
        updateHouseOptions(event.target.value, { selectedHouse: '', selectedRooms: [], keepValue: false });
      });

      refs.positionHouse?.addEventListener('change', (event) => {
        updateRoomOptions(event.target.value, { selectedRooms: [], keepValue: false });
      });

      const showStep = (requestedStep, { syncUrl = true } = {}) => {
        const step = availableSteps.has(requestedStep) ? requestedStep : (sortedSteps[0] ?? requestedStep);

        refs.sections.forEach((section) => {
          const current = Number(section.getAttribute('data-step-index'));
          if (current === step) {
            section.classList.remove('hidden');
          } else {
            section.classList.add('hidden');
          }
        });

        refs.navButtons.forEach((button) => {
          const target = Number(button.getAttribute('data-step-trigger'));
          if (target === step) {
            button.classList.add('bg-brand', 'text-white');
            button.classList.remove('text-slate-600');
          } else {
            button.classList.remove('bg-brand', 'text-white');
            button.classList.add('text-slate-600');
          }
        });

        if (view === 'configurator' && syncUrl) {
          const url = new URL(window.location.href);
          const slug = stepSlugMap[step];
          if (slug) {
            url.searchParams.set('step', slug);
          } else {
            url.searchParams.delete('step');
          }
          const newUrl = `${url.pathname}${url.search}${url.hash}`;
          window.history.replaceState({}, '', newUrl);
        }
      };

      refs.navButtons.forEach((button) => {
        button.addEventListener('click', () => {
          const target = Number(button.getAttribute('data-step-trigger'));
          showStep(target);
        });
      });

      app.querySelectorAll('[data-action="next"]').forEach((button) => {
        button.addEventListener('click', () => {
          const next = Number(button.getAttribute('data-next-step'));
          showStep(next);
        });
      });

      app.querySelectorAll('[data-action="prev"]').forEach((button) => {
        button.addEventListener('click', () => {
          const prev = Number(button.getAttribute('data-prev-step'));
          showStep(prev);
        });
      });

      const renderPositions = () => {
        if (!refs.positionsBody || !state.metadata) {
          return;
        }

        const includeInactive = state.filters.includeInactivePositions;
        const rawPositions = Array.isArray(state.metadata.positions)
          ? [...state.metadata.positions]
          : [];
        const getOrderValue = (item) => {
          const raw = Number(item?.display_order);
          return Number.isFinite(raw) ? raw : 0;
        };

        rawPositions.sort((a, b) => {
          const diff = getOrderValue(a) - getOrderValue(b);
          if (diff !== 0) {
            return diff;
          }
          return (a.id || 0) - (b.id || 0);
        });

        const visiblePositions = includeInactive
          ? rawPositions
          : rawPositions.filter((position) => position.is_active);

        if (!visiblePositions.length) {
          const emptyMessage = includeInactive
            ? 'No hay posiciones registradas en este momento.'
            : 'No hay posiciones activas en este momento.';
          refs.positionsBody.innerHTML = `<tr><td colspan="5" class="px-3 py-4 text-center text-sm text-slate-500">${emptyMessage}</td></tr>`;
          return;
        }

        const allowReorder =
          !state.orderLocked && Boolean(API.positionReorder) && visiblePositions.length > 1;

        if (refs.positionOrderStatus) {
          if (state.orderLocked) {
            refs.positionOrderStatus.classList.remove('hidden');
          } else {
            refs.positionOrderStatus.classList.add('hidden');
          }
        }

        refs.positionsBody.innerHTML = visiblePositions
          .map((position, index) => {
            const orderValue = getOrderValue(position);
            const orderLabel = orderValue > 0 ? orderValue : index + 1;
            const complexityLabel =
              state.lookups.complexityLabels.get(position.complexity) || position.complexity;
            const validity = position.valid_until
              ? `${escapeHtml(position.valid_from)} → ${escapeHtml(position.valid_until)}`
              : `${escapeHtml(position.valid_from)} → vigencia abierta`;
            const farmLabel = position.farm?.name ? escapeHtml(position.farm.name) : '';
            const houseLabel = position.chicken_house?.name ? escapeHtml(position.chicken_house.name) : '';
            const roomLabels = (position.rooms || []).map((room) => escapeHtml(room.name)).join(', ');
            const isEditing = state.editing.positionId === position.id;
            const rowClassList = ['transition-colors', 'hover:bg-slate-50'];
            if (!position.is_active) {
              rowClassList.push('bg-slate-50', 'text-slate-500');
            }
            if (isEditing) {
              rowClassList.push(
                'bg-amber-50',
                'ring-2',
                'ring-amber-300',
                'ring-offset-1',
                'ring-offset-white'
              );
            }
            const rowAttr = rowClassList.length ? ` class="${rowClassList.join(' ')}"` : '';
            const disableUp = index === 0;
            const disableDown = index === visiblePositions.length - 1;
            const moveButtonBase = 'inline-flex h-7 w-7 items-center justify-center rounded-full bg-slate-200 text-slate-600 shadow-sm transition hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-brand focus:ring-offset-1';
            const disabledClasses = 'cursor-not-allowed opacity-40 hover:bg-slate-200';
            const moveUpClasses = `${moveButtonBase} ${disableUp ? disabledClasses : ''}`;
            const moveDownClasses = `${moveButtonBase} ${disableDown ? disabledClasses : ''}`;
            return `
              <tr${rowAttr} data-position-id="${position.id}">
                <td class="px-3 py-3 align-top">
                  <div class="flex items-start gap-3">
                    <span class="inline-flex items-center justify-center rounded-full bg-slate-200 px-2 text-xs font-semibold text-slate-700">#${orderLabel}</span>
                    <div>
                      <p class="font-semibold text-slate-800">${escapeHtml(position.name)}</p>
                      <p class="text-xs text-slate-500">
                        ${escapeHtml(position.code)}
                        ${farmLabel ? ` · ${farmLabel}` : ''}
                        ${houseLabel ? ` · ${houseLabel}` : ''}
                      </p>
                      ${
                        roomLabels
                          ? `<p class="mt-1 text-xs text-slate-500">Salones: ${roomLabels}</p>`
                          : ''
                      }
                    </div>
                  </div>
                </td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${escapeHtml(complexityLabel)}</td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${validity}</td>
                <td class="px-3 py-3 align-top">
                  <span class="inline-flex items-center rounded-full px-2.5 py-1 text-xs font-medium ${
                    position.is_active ? 'bg-emerald-100 text-emerald-700' : 'bg-slate-200 text-slate-600'
                  }">
                    ${position.is_active ? 'Activo' : 'Inactivo'}
                  </span>
                </td>
                <td class="px-3 py-3 align-top">
                  <div class="flex flex-wrap gap-2">
                    ${
                      allowReorder
                        ? `
                      <div class="flex gap-1">
                        <button type="button" data-action="position-move" data-direction="up" data-id="${position.id}" class="${moveUpClasses}" ${
                            disableUp ? 'disabled' : ''
                          } aria-label="Mover arriba" title="Mover arriba">
                          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path d="M10 5.25a.75.75 0 0 1 .53.22l4.25 4.25a.75.75 0 1 1-1.06 1.06L10 7.06 6.28 10.78a.75.75 0 1 1-1.06-1.06l4.25-4.25A.75.75 0 0 1 10 5.25Z"/>
                          </svg>
                          <span class="sr-only">Mover arriba</span>
                        </button>
                        <button type="button" data-action="position-move" data-direction="down" data-id="${position.id}" class="${moveDownClasses}" ${
                            disableDown ? 'disabled' : ''
                          } aria-label="Mover abajo" title="Mover abajo">
                          <svg class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                            <path d="M9.47 14.53a.75.75 0 0 0 1.06 0l4.25-4.25a.75.75 0 1 0-1.06-1.06L10 12.44 6.28 9.22a.75.75 0 1 0-1.06 1.06l4.25 4.25Z"/>
                          </svg>
                          <span class="sr-only">Mover abajo</span>
                        </button>
                      </div>
                    `
                        : ''
                    }
                    <button type="button" data-action="position-edit" data-id="${position.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                    <button type="button" data-action="position-delete" data-id="${position.id}" class="rounded border border-red-200 px-2 py-1 text-xs text-red-700 hover:bg-red-50">Eliminar</button>
                  </div>
                </td>
              </tr>
            `;
          })
          .join('');
      };

      const renderOperators = () => {
        if (!state.metadata || !refs.operatorBody) {
          return;
        }

        const searchTerm = (refs.operatorSearch?.value || '').toLowerCase();
        const categoryFilter = refs.operatorCategoryFilter?.value || '';
        const includeInactiveOperators = state.filters.includeInactiveOperators;

        const { operators = [], capabilities = [] } = state.metadata;
        const capabilitiesByOperator = capabilities.reduce((acc, capability) => {
          const list = acc.get(capability.operator_id) || [];
          list.push(capability);
          acc.set(capability.operator_id, list);
          return acc;
        }, new Map());

        const filtered = operators.filter((operator) => {
          if (!includeInactiveOperators && !operator.is_active) {
            return false;
          }
          const name = (operator.name || '').toLowerCase();
          const document = (operator.document || '').toLowerCase();
          const matchesSearch = !searchTerm || name.includes(searchTerm) || document.includes(searchTerm);
          if (!matchesSearch) {
            return false;
          }

          if (!categoryFilter) {
            return true;
          }

          const operatorCapabilities = capabilitiesByOperator.get(operator.id) || [];
          return operatorCapabilities.some((item) => String(item.category_id ?? item.category?.id ?? '') === categoryFilter);
        });

        if (refs.operatorCount) {
          refs.operatorCount.textContent = `${filtered.length} colaboradores`;
        }
        if (refs.capabilityCount) {
          refs.capabilityCount.textContent = `${capabilities.length} fortalezas activas`;
        }

        if (!filtered.length) {
          refs.operatorBody.innerHTML =
            '<tr><td colspan="5" class="px-3 py-4 text-center text-sm text-slate-500">No encontramos colaboradores con ese criterio.</td></tr>';
          return;
        }

        refs.operatorBody.innerHTML = filtered
          .map((operator) => {
            const operatorCapabilities = capabilitiesByOperator.get(operator.id) || [];
            const positionsList = operatorCapabilities.map((capability) => {
              const categoryValue = String(capability.category_id ?? capability.category?.id ?? '');
              const categoryLabel = state.lookups.categoryLabels.get(categoryValue) || capability.category?.name || categoryValue;
              const skillLabel = state.lookups.skillLabels.get(String(capability.skill_score)) || `${capability.skill_score}/10`;
              return `${escapeHtml(categoryLabel)} (${escapeHtml(skillLabel)})`;
            });
            const positionsDisplay = positionsList.join(', ') || 'Sin fortalezas activas';

            const preferredFarm = operator.preferred_farm
              ? state.lookups.farmsById.get(operator.preferred_farm.id) || operator.preferred_farm
              : null;
            const preferredFarmLabel = preferredFarm ? escapeHtml(preferredFarm.name) : 'Sin preferencia';

            const roles = (operator.roles || []).map((role) => escapeHtml(role.label)).join(', ');
            const rolesLine = roles
              ? `<p class="text-xs text-slate-500">Roles: ${roles}</p>`
              : '';
            const statusBadge = operator.is_active
              ? '<span class="inline-flex items-center rounded-full bg-emerald-100 px-2.5 py-1 text-xs font-medium text-emerald-700">Activo</span>'
              : '<span class="inline-flex items-center rounded-full bg-slate-200 px-2.5 py-1 text-xs font-medium text-slate-600">Inactivo</span>';
            const toggleLabel = operator.is_active ? 'Deshabilitar' : 'Habilitar';
            const toggleClasses = operator.is_active
              ? 'border-red-200 text-red-700 hover:bg-red-50'
              : 'border-emerald-300 text-emerald-700 hover:bg-emerald-100';
            const desiredState = operator.is_active ? 'false' : 'true';
            const isEditing = state.editing.operatorId === operator.id;
            const rowClassList = ['transition-colors'];
            if (isEditing) {
              rowClassList.push(
                'bg-amber-50',
                'ring-2',
                'ring-amber-300',
                'ring-offset-1',
                'ring-offset-white',
                'hover:bg-amber-50'
              );
            } else {
              rowClassList.push('hover:bg-slate-50');
              if (operator.is_active) {
                rowClassList.push('bg-white');
              } else {
                rowClassList.push('bg-slate-50', 'text-slate-500');
              }
            }
            if (isEditing) {
              rowClassList.push('bg-amber-50', 'ring-2', 'ring-amber-300', 'ring-offset-1', 'ring-offset-white');
            }
            const rowClasses = rowClassList.join(' ');
            const contactLine = operator.telefono
              ? `${escapeHtml(operator.document)} · ${escapeHtml(operator.telefono)}`
              : escapeHtml(operator.document);
            const emailLine = operator.email
              ? `<p class="text-xs text-slate-500">${escapeHtml(operator.email)}</p>`
              : '';
        const employmentLine = operator.employment_start
          ? `<p class="text-xs text-slate-500">Vinculación: ${escapeHtml(formatDateLabel(operator.employment_start))}${
              operator.employment_end ? ' → ' + escapeHtml(formatDateLabel(operator.employment_end)) : ''
            }</p>`
          : operator.employment_end
            ? `<p class="text-xs text-slate-500">Retiro: ${escapeHtml(formatDateLabel(operator.employment_end))}</p>`
            : '';

            return `
              <tr class="${rowClasses}" data-operator-id="${operator.id}">
                <td class="px-3 py-3 align-top">
                  <p class="font-semibold text-slate-800">${escapeHtml(operator.name)}</p>
                  <p class="text-xs text-slate-500">${contactLine}</p>
                  ${emailLine}
                  ${employmentLine}
                  ${rolesLine}
                </td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${positionsDisplay}</td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${preferredFarmLabel}</td>
                <td class="px-3 py-3 align-top text-sm text-slate-600">${statusBadge}</td>
                <td class="px-3 py-3 align-top min-w-[12rem]">
                  <div class="flex items-center gap-2 whitespace-nowrap">
                    <button type="button" data-action="operator-edit" data-id="${operator.id}" class="rounded border border-slate-300 px-2 py-1 text-xs text-slate-600 hover:bg-slate-100">Editar</button>
                    <button type="button" data-action="operator-toggle" data-id="${operator.id}" data-active="${desiredState}" class="rounded border ${toggleClasses} px-2 py-1 text-xs">${toggleLabel}</button>
                  </div>
                </td>
              </tr>
            `;
          })
          .join('');
      };

      const populateCategoryFilter = () => {
        if (!refs.operatorCategoryFilter || !state.metadata) {
          return;
        }

        const select = refs.operatorCategoryFilter;
        const currentValue = select.value;
        select.innerHTML = '<option value="">Todas las categorías</option>' + state.metadata.choice_sets.position_categories
          .map((choice) => `<option value="${escapeHtml(choice.value)}">${escapeHtml(choice.label)}</option>`)
          .join('');

        if (currentValue) {
          select.value = currentValue;
        }
      };

      const renderSummary = (summary) => {
        if (!refs.summaryPreview) {
          return;
        }

        if (!summary) {
          refs.summaryPreview.innerHTML = '<p class="text-slate-500">El resumen aparecerá después de generar el calendario.</p>';
          refs.calendarActions.hidden = true;
          refs.reloadSummaryBtn.classList.add('hidden');
          return;
        }

        const stats = summary.stats || {};
        const rows = summary.rows || [];
        const firstRows = rows.slice(0, 5).map((row) => {
          const position = row.position;
          const firstAssignment = (row.cells || []).find((cell) => cell.assignment);
          const operatorName = firstAssignment?.assignment?.operator?.name || 'Sin cobertura';
          const alertLabel = firstAssignment?.assignment?.alert_level || 'none';
          return `
            <tr>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(position.name)}</td>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(operatorName)}</td>
              <td class="px-3 py-2 text-sm text-slate-600">${escapeHtml(alertLabel)}</td>
            </tr>
          `;
        }).join('');

        refs.summaryPreview.innerHTML = `
          <div class="grid gap-3 text-sm text-slate-600">
            <div class="grid grid-cols-2 gap-3">
              <div class="rounded border border-emerald-200 bg-emerald-50 px-3 py-2">
                <p class="text-xs text-emerald-800">Asignaciones</p>
                <p class="text-lg font-semibold text-emerald-800">${stats.total_assignments ?? 0}</p>
              </div>
              <div class="rounded border border-amber-200 bg-amber-50 px-3 py-2">
                <p class="text-xs text-amber-800">Alertas</p>
                <p class="text-lg font-semibold text-amber-800">${(stats.warn ?? 0) + (stats.critical ?? 0)}</p>
              </div>
            </div>
            <div class="rounded border border-slate-200">
              <table class="min-w-full divide-y divide-slate-200 text-xs">
                <thead class="bg-slate-100 font-semibold text-slate-600">
                  <tr>
                    <th class="px-3 py-2 text-left">Posición</th>
                    <th class="px-3 py-2 text-left">Operario inicial</th>
                    <th class="px-3 py-2 text-left">Alerta</th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-slate-100">${firstRows || '<tr><td colspan="3" class="px-3 py-2 text-center text-slate-500">Sin asignaciones registradas.</td></tr>'}</tbody>
              </table>
            </div>
          </div>
        `;

        refs.calendarActions.hidden = false;
        refs.reloadSummaryBtn.classList.remove('hidden');
      };

      const fetchSummary = () => {
        if (!state.calendarId) {
          renderSummary(null);
          return;
        }

        apiRequest(replaceId(API.summaryTemplate, state.calendarId))
          .then((response) => {
            if (!response.ok) {
              throw new Error('No fue posible obtener el resumen.');
            }
            return response.json();
          })
          .then((data) => {
            state.lastSummary = data;
            renderSummary(data);
          })
          .catch((error) => {
            console.error(error);
            refs.summaryPreview.innerHTML = '<p class="text-sm text-red-600">No se pudo actualizar el resumen, intenta más tarde.</p>';
          });
      };

      const setFeedback = (message, tone = 'info') => {
        if (!refs.calendarFeedback) {
          return;
        }

        refs.calendarFeedback.classList.remove('hidden');
        refs.calendarFeedback.className = 'rounded border px-4 py-3 text-sm';

        if (tone === 'error') {
          refs.calendarFeedback.classList.add('border-red-200', 'bg-red-50', 'text-red-700');
        } else if (tone === 'success') {
          refs.calendarFeedback.classList.add('border-emerald-200', 'bg-emerald-50', 'text-emerald-800');
        } else {
          refs.calendarFeedback.classList.add('border-slate-200', 'bg-slate-50', 'text-slate-600');
        }

        refs.calendarFeedback.textContent = message;
      };

      const generateCalendar = () => {
        const nameInput = document.getElementById('calendar-name');
        const startInput = document.getElementById('calendar-start');
        const endInput = document.getElementById('calendar-end');
        const notesInput = document.getElementById('calendar-notes');

        if (!startInput?.value || !endInput?.value) {
          setFeedback('Debes ingresar fecha de inicio y fin antes de generar.', 'error');
          return;
        }

        const payload = {
          name: nameInput?.value || '',
          start_date: startInput.value,
          end_date: endInput.value,
          notes: notesInput?.value || '',
        };

        setFeedback('Generando calendario, por favor espera…');

        apiRequest(API.generate, { method: 'POST', body: payload })
          .then((response) => {
            if (!response.ok) {
              return response.text().then((text) => {
                throw new Error(text || 'No fue posible generar el calendario.');
              });
            }
            return response.json();
          })
          .then((data) => {
            state.calendarId = data.calendar_id;
            state.orderLocked = true;
            renderPositions();
            updateMetadataStatus('El orden de las posiciones ha sido bloqueado para este borrador.', 'info');
            setFeedback('Calendario generado con éxito. Revisa el resumen y ajusta las asignaciones antes de aprobar.', 'success');
            if (refs.calendarDetailLink && API.calendarDetailTemplate) {
              refs.calendarDetailLink.href = replaceId(API.calendarDetailTemplate, state.calendarId);
            }
            fetchSummary();
          })
          .catch((error) => {
            console.error(error);
            setFeedback(error.message || 'Ocurrió un error durante la generación.', 'error');
          });
      };

      refs.operatorForm?.addEventListener('submit', (event) => {
        event.preventDefault();
        const payload = getOperatorPayload();
        const id = refs.operatorId?.value;
        submitEntity({
          url: id ? replaceId(API.operatorDetailTemplate, id) : API.operators,
          method: id ? 'PATCH' : 'POST',
          payload,
          messageRef: refs.operatorMessage,
          successMessage: id ? 'Colaborador actualizado correctamente.' : 'Colaborador registrado correctamente.',
          onSuccess: () => {
            closeOperatorForm();
          },
        });
      });

      
      refs.positionForm?.addEventListener('submit', (event) => {
        event.preventDefault();
        const payload = getPositionPayload();
        const id = refs.positionId?.value;
        submitEntity({
          url: id ? replaceId(API.positionDetailTemplate, id) : API.positions,
          method: id ? 'PATCH' : 'POST',
          payload,
          messageRef: refs.positionMessage,
          successMessage: id ? 'Posición actualizada correctamente.' : 'Posición creada correctamente.',
          onSuccess: () => {
            closePositionForm();
          },
        });
      });

      refs.operatorAddBtn?.addEventListener('click', () => openOperatorForm());
      refs.operatorCancelBtn?.addEventListener('click', () => closeOperatorForm());
      refs.operatorRefreshBtn?.addEventListener('click', () => fetchMetadata());
      refs.positionAddBtn?.addEventListener('click', () => openPositionForm());
      refs.positionCancelBtn?.addEventListener('click', () => closePositionForm());
      refs.operatorCapabilityAddBtn?.addEventListener('click', () => addOperatorCapabilityRow());
      refs.operatorRestAddBtn?.addEventListener('click', () => openRestForm());
      refs.operatorRestCancelBtn?.addEventListener('click', () => closeRestForm());
      refs.operatorRestFilters?.addEventListener('click', (event) => {
        const button = event.target.closest('.rest-filter-btn');
        if (!button) {
          return;
        }
        const key = button.dataset.filter;
        if (!key) {
          return;
        }
        if (key === 'last15' || key === 'next15') {
          state.restFilters[key] = !state.restFilters[key];
        } else {
          state.restFilters[key] = !state.restFilters[key];
          if (!state.restFilters.past && !state.restFilters.current && !state.restFilters.future) {
            state.restFilters[key] = true;
          }
        }
        syncRestFiltersUI();
        renderOperatorRestList(state.editing.restOperatorId);
      });
      refs.operatorRestSaveBtn?.addEventListener('click', () => {
        const payload = buildRestPayload();
        if (!payload.operator) {
          setFormMessage(refs.operatorRestMessage, 'Debes seleccionar un colaborador válido.', 'error');
          return;
        }
        if (!Number.isFinite(payload.operator)) {
          setFormMessage(refs.operatorRestMessage, 'El identificador del colaborador no es válido.', 'error');
          return;
        }
        if (!payload.start_date || !payload.end_date) {
          setFormMessage(refs.operatorRestMessage, 'Debes ingresar fechas de inicio y fin.', 'error');
          return;
        }
        const restIdRaw = refs.operatorRestId?.value || '';
        const restId = restIdRaw ? Number.parseInt(restIdRaw, 10) : null;
        const rangeLabel = `${formatDateLabel(payload.start_date)} → ${formatDateLabel(payload.end_date)}`;
        if (!confirmRestAction(`¿Confirmas guardar el descanso ${rangeLabel}?`)) {
          return;
        }
        persistRestPeriod(payload, {
          id: restId,
          successMessage: restId ? 'Descanso actualizado correctamente.' : 'Descanso registrado correctamente.',
        });
      });
      refs.positionsRefreshBtn?.addEventListener('click', () => fetchMetadata());
      refs.positionIncludeInactive?.addEventListener('change', (event) => {
        state.filters.includeInactivePositions = Boolean(event.target?.checked);
        fetchMetadata();
      });
      refs.operatorIncludeInactive?.addEventListener('change', (event) => {
        state.filters.includeInactiveOperators = Boolean(event.target?.checked);
        renderOperators();
      });
      refs.reloadSummaryBtn?.addEventListener('click', () => fetchSummary());
      refs.generateCalendarBtn?.addEventListener('click', () => generateCalendar());
      syncRestFiltersUI();

      const handlePositionMove = (id, direction) => {
        if (!state.metadata) {
          return;
        }
        if (state.orderLocked) {
          updateMetadataStatus('No es posible reordenar las posiciones después de generar el calendario.', 'warning');
          return;
        }
        const delta = direction === 'up' ? -1 : direction === 'down' ? 1 : 0;
        if (!delta) {
          return;
        }

        const positions = Array.isArray(state.metadata.positions)
          ? [...state.metadata.positions]
          : [];
        if (positions.length < 2) {
          return;
        }

        const currentIndex = positions.findIndex((position) => position.id === id);
        if (currentIndex < 0) {
          return;
        }
        const targetIndex = currentIndex + delta;
        if (targetIndex < 0 || targetIndex >= positions.length) {
          return;
        }

        const swapped = [...positions];
        [swapped[currentIndex], swapped[targetIndex]] = [swapped[targetIndex], swapped[currentIndex]];
        const orderedIds = swapped.map((position) => position.id);
        persistPositionOrder(orderedIds, swapped);
      };

      const handleOperatorEdit = (id) => {
        const operator = state.metadata?.operators?.find((item) => item.id === id);
        if (!operator) {
          updateMetadataStatus('No encontramos datos para el colaborador seleccionado.', 'warning');
          return;
        }
        openOperatorForm(operator);
      };

      const handleOperatorToggle = (id, nextActive) => {
        const enable = Boolean(nextActive);
        if (!enable) {
          const confirmed = confirm('¿Deshabilitar este colaborador? Podrás habilitarlo nuevamente cuando lo necesites.');
          if (!confirmed) {
            return;
          }
        }
        submitEntity({
          url: replaceId(API.operatorDetailTemplate, id),
          method: 'PATCH',
          payload: { is_active: enable },
          messageRef: refs.metadataStatus,
          successMessage: enable ? 'Colaborador habilitado.' : 'Colaborador deshabilitado.',
        });
      };

      const handlePositionEdit = (id) => {
        const position = state.metadata?.positions?.find((item) => item.id === id);
        if (!position) {
          return;
        }
        openPositionForm(position);
      };

      const handlePositionDelete = (id) => {
        if (!confirm('¿Confirma eliminar esta posición? Esta acción no se puede deshacer.')) {
          return;
        }
        deleteEntity(replaceId(API.positionDetailTemplate, id), {
          afterSuccess: () => {
            if (refs.positionId?.value === String(id)) {
              closePositionForm();
            }
          },
        });
      };

      app.addEventListener('click', (event) => {
        const target = event.target.closest('[data-action]');
        if (!target) {
          return;
        }
        const action = target.dataset.action;
        const idRaw = target.dataset.id;
        const id = idRaw !== undefined ? Number.parseInt(idRaw, 10) : NaN;
        switch (action) {
          case 'operator-edit':
            handleOperatorEdit(id);
            break;
          case 'operator-toggle':
            handleOperatorToggle(id, target.dataset.active === 'true');
            break;
          case 'position-move':
            handlePositionMove(id, target.dataset.direction);
            break;
          case 'position-edit':
            handlePositionEdit(id);
            break;
          case 'position-delete':
            handlePositionDelete(id);
            break;
          case 'rest-edit': {
            if (!Number.isFinite(id) || id <= 0) {
              return;
            }
            const period = getRestPeriodById(id);
            if (!period) {
              updateMetadataStatus('No encontramos el descanso seleccionado.', 'warning');
              return;
            }
            openRestForm(period);
            break;
          }
          case 'rest-delete': {
            if (!Number.isFinite(id) || id <= 0) {
              return;
            }
            const period = getRestPeriodById(id);
            if (!period) {
              updateMetadataStatus('No encontramos el descanso seleccionado.', 'warning');
              return;
            }
            const label = formatRestRange(period);
            if (!confirmRestAction(`¿Eliminar el descanso ${label}?`)) {
              return;
            }
            deleteRestPeriod(period);
            break;
          }
          default:
            break;
        }
      });

      const fetchMetadata = async () => {
        updateMetadataStatus('Cargando información…', 'info');
        try {
          const params = new URLSearchParams();
          if (state.filters.includeInactivePositions) {
            params.set('include_inactive', 'true');
          }
          const url = params.toString() ? `${API.metadata}?${params.toString()}` : API.metadata;
          const response = await apiRequest(url);
          if (!response.ok) {
            throw new Error('No fue posible obtener los datos.');
          }
          const data = await response.json();
          state.metadata = data;
          if (Array.isArray(state.metadata?.positions)) {
            state.metadata.positions.sort((a, b) => {
              const orderA = Number(a?.display_order);
              const orderB = Number(b?.display_order);
              const safeA = Number.isFinite(orderA) ? orderA : 0;
              const safeB = Number.isFinite(orderB) ? orderB : 0;
              if (safeA !== safeB) {
                return safeA - safeB;
              }
              return (a.id || 0) - (b.id || 0);
            });
          }
          if (refs.positionIncludeInactive) {
            refs.positionIncludeInactive.checked = state.filters.includeInactivePositions;
          }
          if (refs.operatorIncludeInactive) {
            refs.operatorIncludeInactive.checked = state.filters.includeInactiveOperators;
          }
          rebuildLookups();
          populateStaticOptions();
          renderPositions();
          populateCategoryFilter();
          renderOperators();
          renderOperatorCapabilitiesEditor();
          renderOperatorRestList(state.editing.restOperatorId);
          syncRestFiltersUI();
          updateMetadataStatus('Información actualizada.', 'success');
        } catch (error) {
          console.error(error);
          updateMetadataStatus('Error cargando datos. Intenta nuevamente o revisa tu conexión.', 'error');
        }
      };

      const initFilters = () => {
        refs.operatorSearch?.addEventListener('input', () => renderOperators());
        refs.operatorCategoryFilter?.addEventListener('change', () => renderOperators());
      };

      const resolveInitialStep = () => {
        if (!sortedSteps.length) {
          return { step: 1, source: null };
        }
        const url = new URL(window.location.href);
        const hashValue = (url.hash || '').replace('#', '').trim();
        let source = null;
        let raw = (url.searchParams.get('step') || '').trim();
        if (raw) {
          source = 'search';
        } else if (hashValue) {
          source = 'hash';
          raw = hashValue.toLowerCase().startsWith('step=') ? hashValue.slice(5) : hashValue;
        }
        const candidate = raw.toLowerCase();
        if (candidate && slugToStep.has(candidate)) {
          const mapped = slugToStep.get(candidate);
          if (availableSteps.has(mapped)) {
            return { step: mapped, source };
          }
        }
        const numericCandidate = Number(candidate);
        if (candidate && !Number.isNaN(numericCandidate) && availableSteps.has(numericCandidate)) {
          return { step: numericCandidate, source };
        }
        return { step: sortedSteps[0], source: null };
      };

      initFilters();
      fetchMetadata();
      const { step: initialStep, source: initialSource } = resolveInitialStep();
      const syncInitialStep = initialSource !== null;
      showStep(initialStep, { syncUrl: syncInitialStep });
      refs.generateCalendarBtn?.addEventListener('click', () => generateCalendar());
      refs.reloadSummaryBtn?.addEventListener('click', () => fetchSummary());
    })();
  </script>
